<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CONVERSATION_BASED_NOTIFICATIONS.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CONVERSATION_BASED_NOTIFICATIONS.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# Conversation-Based Notification System - Implementation Complete&#10;&#10;## Overview&#10;The Smart Notifications tab has been completely redesigned to show notifications as **conversations** (like WhatsApp, Messenger, Instagram) instead of individual notification cards.&#10;&#10;## Key Concepts&#10;&#10;### Display Names Logic (Like Real Messaging Apps)&#10;&#10;#### In Inbox (Conversation List):&#10;- **Shows: OTHER person's name** (e.g., &quot;Biplov Gautam&quot;)&#10;- **Never shows: &quot;You&quot; or current user's name**&#10;- This matches how WhatsApp/Messenger work - you see who you're chatting WITH, not yourself&#10;&#10;#### In Chat View (Message Thread):&#10;- **Shows: WHO sent each message** via `sender_name`&#10;- Incoming messages show the sender's name (e.g., &quot;Biplov Gautam&quot;)&#10;- Each message can have different sender (useful for group chats)&#10;- AI replies are labeled with &quot;✨ AI Reply&quot;&#10;&#10;#### Example:&#10;```&#10;INBOX:&#10;┌─────────────────────────────┐&#10;│  Biplov Gautam      5m ago│  ← Shows OTHER person&#10;│  WhatsApp                 │&#10;│ Are you free tomorrow?   [2]│&#10;└─────────────────────────────┘&#10;&#10;CHAT VIEW:&#10;┌─────────────────────────────┐&#10;│ ←  Biplov Gautam          │  ← Header shows OTHER person&#10;│    WhatsApp                │&#10;├─────────────────────────────┤&#10;│  ┌────────────────────┐     │&#10;│  │ Biplov Gautam      │     │  ← Sender name on message&#10;│  │ Hey, how are you?  │     │&#10;│  │ 14:30              │     │&#10;│  └────────────────────┘     │&#10;│                              │&#10;│     ┌────────────────────┐  │&#10;│     │ ✨ AI Reply        │  │  ← AI-generated reply&#10;│     │ I'm doing great!   │  │&#10;│     └────────────────────┘  │&#10;└─────────────────────────────┘&#10;```&#10;&#10;## Architecture&#10;&#10;### In-Memory Storage (NotificationMemoryStore)&#10;&#10;Two data structures are now maintained:&#10;&#10;#### Table 1: Conversations (Inbox)&#10;```kotlin&#10;data class Conversation(&#10;    val convo_id: String,          // e.g., &quot;com.whatsapp_170762839&quot;&#10;    val package_name: String,       // e.g., &quot;com.whatsapp&quot;&#10;    val display_name: String,       // OTHER person's name (e.g., &quot;Biplov Gautam&quot;)&#10;    val last_msg_time: Long,        // Timestamp for sorting&#10;    val last_msg_content: String,   // Last message preview&#10;    val platform_id: String? = null,// Optional platform-specific ID&#10;    val unread_count: Int = 0       // Number of unread messages&#10;)&#10;```&#10;&#10;**Important:** `display_name` is ALWAYS the other person's name, not &quot;You&quot;&#10;&#10;#### Table 2: Messages (Chat History)&#10;```kotlin&#10;data class Message(&#10;    val msg_id: String,             // Using hash as unique ID&#10;    val convo_id: String,           // Foreign key to Conversation&#10;    val sender_name: String,        // WHO sent THIS specific message&#10;    val msg_content: String,        // The text&#10;    val timestamp: Long,            // When it was sent&#10;    val is_outgoing: Boolean = false, // True if from current user&#10;    val msg_hash: String,           // Deduplication&#10;    val has_reply_action: Boolean = false,&#10;    val ai_reply: String = &quot;&quot;,&#10;    val is_sent: Boolean = false&#10;)&#10;```&#10;&#10;**Important:** `sender_name` identifies who sent EACH message (can be different in group chats)&#10;&#10;## UI Flow&#10;&#10;### 1. Inbox View (Conversation List)&#10;When you open Smart Notifications tab, you see:&#10;- ✅ **List of conversations** (like messaging app inbox)&#10;- ✅ **Avatar with platform badge** (WhatsApp/Instagram/Messenger indicator)&#10;- ✅ **Display name** (sender or group name)&#10;- ✅ **Last message preview**&#10;- ✅ **Timestamp** (relative time: &quot;5m ago&quot;, &quot;yesterday&quot;, etc.)&#10;- ✅ **Unread count badge** (shows number of unread messages)&#10;- ✅ **Platform filters** (All, WhatsApp, Instagram, Messenger, General)&#10;&#10;### 2. Chat View (Message Thread)&#10;When you click on a conversation, you see:&#10;- ✅ **Header** with back button, avatar, name, and platform&#10;- ✅ **Message bubbles** (chronological order)&#10;  - Original messages (left-aligned, gray)&#10;  - AI replies (right-aligned, green with ✨ icon)&#10;- ✅ **Sender name** and timestamp on each message&#10;- ✅ **Action buttons** for each message:&#10;  - &quot;Generate Reply&quot; - Creates AI reply&#10;  - &quot;Send&quot; - Sends the AI reply&#10;- ✅ **Status indicators**:&#10;  - ✅ Checkmark when reply is sent&#10;  -  Loading indicator when generating&#10;&#10;## Features&#10;&#10;### Automatic Grouping&#10;- Messages are automatically grouped by `conversationId`&#10;- Each conversation shows in the inbox only once&#10;- Unread count updates automatically&#10;&#10;### Smart Sorting&#10;- Conversations sorted by `last_msg_time` (most recent first)&#10;- Messages within conversation sorted chronologically&#10;&#10;### Deduplication&#10;- Uses `msg_hash` to prevent duplicate messages&#10;- Hash based on: title + text + package&#10;&#10;name&#10;&#10;### State Management&#10;- All data stored in Compose State (`mutableStateListOf`)&#10;- UI auto-updates when new notifications arrive&#10;- Survives configuration changes&#10;&#10;### Memory Management&#10;- Max 100 messages per conversation&#10;- Max 500 total notifications&#10;- Older messages automatically pruned&#10;&#10;## Key Methods&#10;&#10;### NotificationMemoryStore&#10;&#10;```kotlin&#10;// Get all conversations sorted by last message time&#10;getAllConversations(): List&lt;Conversation&gt;&#10;&#10;// Get messages for a specific conversation&#10;getMessagesForConversation(convo_id: String): List&lt;Message&gt;&#10;&#10;// Mark conversation as read (clears unread count)&#10;markConversationAsRead(convo_id: String)&#10;&#10;// Update AI reply for a message&#10;updateMessageAIReply(msg_hash: String, aiReply: String): Boolean&#10;&#10;// Mark message as sent&#10;markMessageAsSent(msg_hash: String): Boolean&#10;```&#10;&#10;### Automatic Updates&#10;&#10;When `addNotification()` is called:&#10;1. ✅ Adds to notifications list (original behavior)&#10;2. ✅ Updates or creates Conversation entry&#10;3. ✅ Adds Message entry&#10;4. ✅ Updates last_msg_time and last_msg_content&#10;5. ✅ Increments unread_count&#10;6. ✅ Moves conversation to top of inbox&#10;&#10;## UI Components&#10;&#10;### ConversationInboxView&#10;- Shows list of conversations&#10;- Platform filter chips&#10;- Empty state when no conversations&#10;&#10;### ConversationInboxItem&#10;- Card showing conversation details&#10;- Avatar with platform badge&#10;- Name, last message, timestamp&#10;- Unread count badge&#10;&#10;### ConversationChatView&#10;- Header with back button&#10;- Message list (LazyColumn)&#10;- Empty state when no messages&#10;&#10;### MessageBubble&#10;- Original message (gray, left)&#10;- AI reply (green, right) if available&#10;- Action buttons (Generate Reply, Send)&#10;- Status indicators&#10;&#10;## Comparison: Before vs After&#10;&#10;### Before (Individual Notifications)&#10;```&#10;┌─────────────────────────────┐&#10;│ Notification 1              │&#10;│ WhatsApp - Biplov           │&#10;│ &quot;Hey, how are you?&quot;         │&#10;│ [Generate Reply] [Send]     │&#10;└─────────────────────────────┘&#10;┌─────────────────────────────┐&#10;│ Notification 2              │&#10;│ WhatsApp - Biplov           │&#10;│ &quot;Are you free tomorrow?&quot;    │&#10;│ [Generate Reply] [Send]     │&#10;└─────────────────────────────┘&#10;```&#10;&#10;### After (Conversation-Based)&#10;```&#10;INBOX:&#10;┌─────────────────────────────┐&#10;│  Biplov Gautam      5m ago│&#10;│  WhatsApp                 │&#10;│ Are you free tomorrow?   [2]│&#10;└─────────────────────────────┘&#10;&#10;CHAT VIEW (when clicked):&#10;┌─────────────────────────────┐&#10;│ ←  Biplov Gautam          │&#10;│    WhatsApp                │&#10;├─────────────────────────────┤&#10;│  ┌────────────────────┐     │&#10;│  │ Biplov Gautam      │     │&#10;│  │ Hey, how are you?  │     │&#10;│  │ 14:30              │     │&#10;│  └────────────────────┘     │&#10;│                              │&#10;│     ┌────────────────────┐  │&#10;│     │ ✨ AI Reply        │  │&#10;│     │ I'm doing great!   │  │&#10;│     │ Thanks for asking  │  │&#10;│     └────────────────────┘  │&#10;│                              │&#10;│  ┌────────────────────┐     │&#10;│  │ Biplov Gautam      │     │&#10;│  │ Are you free       │     │&#10;│  │ tomorrow?          │     │&#10;│  │ 14:32              │     │&#10;│  └────────────────────┘     │&#10;│  [Generate Reply]            │&#10;└─────────────────────────────┘&#10;```&#10;&#10;## Benefits&#10;&#10;✅ **Natural Messaging Experience** - Like WhatsApp/Messenger&#10;✅ **Better Organization** - Messages grouped by conversation&#10;✅ **Cleaner UI** - One entry per person, not per message&#10;✅ **Conversation Context** - See message history&#10;✅ **Unread Tracking** - Know which conversations need attention&#10;✅ **Easy Navigation** - Back button returns to inbox&#10;✅ **Memory Efficient** - Automatic cleanup of old messages&#10;✅ **Real-time Updates** - Compose state management&#10;&#10;## Raw Tab&#10;&#10;The Raw tab remains unchanged and still shows:&#10;- All raw notification data&#10;- Complete JSON structure with timestamps&#10;- Copyable JSON for analysis&#10;&#10;## Future Enhancements&#10;&#10;- [ ] Search conversations&#10;- [ ] Archive conversations&#10;- [ ] Pin important conversations&#10;- [ ] Bulk mark as read&#10;- [ ] Export conversation history&#10;- [ ] Rich media support (images, emojis)&#10;- [ ] Reply drafts&#10;- [ ] Quick reply from inbox&#10;&#10;## Status&#10;&#10;✅ **Conversation-based inbox working**&#10;✅ **Message thread view working**&#10;✅ **AI reply generation per message**&#10;✅ **Send functionality per message**&#10;✅ **Unread count tracking**&#10;✅ **Platform filtering**&#10;✅ **Automatic grouping and sorting**&#10;✅ **Memory-efficient storage**&#10;&#10;The Smart Notifications tab now provides a complete messaging-app-like experience! &#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/CONVERSATION_SYSTEM_EXPLAINED.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CONVERSATION_SYSTEM_EXPLAINED.md" />
              <option name="updatedContent" value="# Conversation-Based Messaging - How It Works&#10;&#10;## The Core Concept&#10;&#10;Just like in WhatsApp or Messenger:&#10;1. **Inbox shows OTHER people** - You see who you're chatting with, not yourself&#10;2. **Messages show WHO sent them** - Each bubble identifies the sender&#10;3. **Conversations grouped by person** - All messages from one person in one thread&#10;&#10;## Data Flow&#10;&#10;### When a Notification Arrives&#10;&#10;```&#10;Notification from WhatsApp&#10;├─ Title: &quot;Biplov Gautam&quot;&#10;├─ Text: &quot;Hey, how are you?&quot;&#10;├─ Sender: &quot;Biplov Gautam&quot;&#10;└─ ConversationId: &quot;com.whatsapp_170762839&quot;&#10;    ↓&#10;NotificationMemoryStore.addNotification()&#10;    ↓&#10;Creates/Updates Conversation:&#10;├─ convo_id: &quot;com.whatsapp_170762839&quot;&#10;├─ display_name: &quot;Biplov Gautam&quot; ← OTHER person's name&#10;├─ last_msg_content: &quot;Hey, how are you?&quot;&#10;└─ unread_count: +1&#10;    ↓&#10;Creates Message:&#10;├─ msg_id: &quot;843f...07f1&quot;&#10;├─ convo_id: &quot;com.whatsapp_170762839&quot;&#10;├─ sender_name: &quot;Biplov Gautam&quot; ← WHO sent THIS message&#10;├─ msg_content: &quot;Hey, how are you?&quot;&#10;├─ is_outgoing: false ← Because it's an incoming notification&#10;└─ timestamp: 1770851045221&#10;    ↓&#10;UI Auto-Updates (Compose State)&#10;    ↓&#10;Shows in Inbox or Updates Chat View&#10;```&#10;&#10;## UI Structure&#10;&#10;### Level 1: Inbox (Conversation List)&#10;&#10;Shows all conversations, each with:&#10;- **Avatar** - First letter of other person's name&#10;- **Platform Badge** - WhatsApp/Instagram/Messenger indicator&#10;- **Display Name** - OTHER person's name (e.g., &quot;Biplov Gautam&quot;)&#10;- **Last Message** - Preview of most recent message&#10;- **Timestamp** - When last message was received&#10;- **Unread Badge** - Count of unread messages&#10;&#10;```kotlin&#10;// Inbox shows:&#10;Conversation(&#10;    display_name = &quot;Biplov Gautam&quot;,  // ← OTHER person&#10;    last_msg_content = &quot;Hey!&quot;,&#10;    unread_count = 2&#10;)&#10;```&#10;&#10;### Level 2: Chat View (Message Thread)&#10;&#10;When you click a conversation, shows:&#10;- **Header** - Other person's name and platform&#10;- **Message Bubbles** - All messages in chronological order&#10;  - Left-aligned (gray) = Messages FROM other person&#10;  - Right-aligned (green) = AI-generated replies&#10;- **Sender Name** - On each message bubble&#10;- **Timestamp** - On each message&#10;- **Action Buttons** - Generate Reply, Send&#10;&#10;```kotlin&#10;// Messages show actual sender:&#10;Message(&#10;    sender_name = &quot;Biplov Gautam&quot;,  // ← WHO sent this&#10;    msg_content = &quot;Hey, how are you?&quot;,&#10;    is_outgoing = false  // ← Incoming&#10;)&#10;&#10;Message(&#10;    sender_name = &quot;AI&quot;,  // ← Marked as AI reply&#10;    msg_content = &quot;I'm good, thanks!&quot;,&#10;    ai_reply = &quot;I'm good, thanks!&quot;,&#10;    is_outgoing = true  // ← Would be outgoing if sent&#10;)&#10;```&#10;&#10;## Key Fields Explained&#10;&#10;### conversation_id&#10;- Unique identifier for a conversation&#10;- Format: `packageName_uniqueId`&#10;- Example: `&quot;com.whatsapp_170762839&quot;`&#10;- **Purpose:** Groups messages from same chat/person&#10;&#10;### display_name (in Conversation)&#10;- Shows in inbox list&#10;- **Always the OTHER person's name**&#10;- Never shows &quot;You&quot; or current user&#10;- Extracted from `notification.sender` or `notification.title`&#10;&#10;### sender_name (in Message)&#10;- Shows who sent THIS specific message&#10;- Can be different for each message (group chats)&#10;- Used to identify message owner&#10;- **In WhatsApp:**&#10;  - Individual chat: Same as display_name&#10;  - Group chat: Different people&#10;&#10;### is_outgoing&#10;- `false` = Message FROM other person (left-aligned)&#10;- `true` = Message FROM you (right-aligned)&#10;- **Currently:** All notifications are `is_outgoing = false`&#10;- **Future:** If we capture sent messages, those would be `true`&#10;&#10;## Real-World Example&#10;&#10;### Scenario: Chat with &quot;Biplov Gautam&quot;&#10;&#10;#### Inbox View:&#10;```&#10;┌────────────────────────────────┐&#10;│ B  Biplov Gautam        5m ago │  ← Shows OTHER person&#10;│    WhatsApp                  [3]│  ← 3 unread messages&#10;│    Are you free tomorrow?      │&#10;└────────────────────────────────┘&#10;```&#10;&#10;#### Chat View (when clicked):&#10;```&#10;┌────────────────────────────────┐&#10;│ ← B  Biplov Gautam             │  ← Header: OTHER person&#10;│      WhatsApp                   │&#10;├────────────────────────────────┤&#10;│                                 │&#10;│  ┌─────────────────────┐       │&#10;│  │ Biplov Gautam       │       │  ← Message 1 sender&#10;│  │ Hey, how are you?   │       │&#10;│  │ 14:30               │       │&#10;│  └─────────────────────┘       │&#10;│  [Generate Reply]               │&#10;│                                 │&#10;│  ┌─────────────────────┐       │&#10;│  │ Biplov Gautam       │       │  ← Message 2 sender&#10;│  │ Long time no see!   │       │&#10;│  │ 14:31               │       │&#10;│  └─────────────────────┘       │&#10;│  [Generate Reply]               │&#10;│                                 │&#10;│  ┌─────────────────────┐       │&#10;│  │ Biplov Gautam       │       │  ← Message 3 sender&#10;│  │ Are you free        │       │&#10;│  │ tomorrow?           │       │&#10;│  │ 14:32               │       │&#10;│  └─────────────────────┘       │&#10;│                                 │&#10;│      ┌─────────────────────┐   │&#10;│      │ ✨ AI Reply         │   │  ← AI generated reply&#10;│      │ Yes, I'm available  │   │&#10;│      │ tomorrow!           │   │&#10;│      └─────────────────────┘   │&#10;│      [Send]                     │&#10;│                                 │&#10;└────────────────────────────────┘&#10;```&#10;&#10;## Database Structure (In-Memory)&#10;&#10;### Table 1: Conversations&#10;| convo_id | package_name | display_name | last_msg_time | last_msg_content | unread_count |&#10;|----------|--------------|--------------|---------------|------------------|--------------|&#10;| com.whatsapp_170762839 | com.whatsapp | Biplov Gautam | 1770851045221 | Are you free tomorrow? | 3 |&#10;&#10;**Note:** `display_name = &quot;Biplov Gautam&quot;` (OTHER person, not &quot;You&quot;)&#10;&#10;### Table 2: Messages&#10;| msg_id | convo_id | sender_name | msg_content | timestamp | is_outgoing |&#10;|--------|----------|-------------|-------------|-----------|-------------|&#10;| 843f...1 | com.whatsapp_170762839 | Biplov Gautam | Hey, how are you? | 1770851045221 | false |&#10;| 843f...2 | com.whatsapp_170762839 | Biplov Gautam | Long time no see! | 1770851045222 | false |&#10;| 843f...3 | com.whatsapp_170762839 | Biplov Gautam | Are you free tomorrow? | 1770851045223 | false |&#10;&#10;**Note:** Each message has `sender_name = &quot;Biplov Gautam&quot;` (who actually sent it)&#10;&#10;## Why This Design?&#10;&#10;### ✅ Natural Experience&#10;- Matches WhatsApp/Messenger behavior&#10;- Users instantly understand the interface&#10;- No confusion about &quot;who is who&quot;&#10;&#10;### ✅ Accurate Attribution&#10;- Each message knows WHO sent it&#10;- Important for group chats (multiple senders)&#10;- Clear distinction between incoming and AI replies&#10;&#10;### ✅ Scalable&#10;- Works for 1-on-1 chats&#10;- Works for group chats (multiple senders)&#10;- Works for broadcast messages&#10;&#10;### ✅ Consistent&#10;- Inbox shows conversations (people you chat with)&#10;- Chat view shows messages (what was said)&#10;- AI replies clearly marked&#10;&#10;## Future Enhancements&#10;&#10;When we want to support sent messages:&#10;```kotlin&#10;// Detect if message is from current user&#10;val currentUserName = getCurrentUserDisplayName()&#10;val is_outgoing = (sender_name == currentUserName)&#10;&#10;// Then in UI:&#10;if (message.is_outgoing) {&#10;    // Show right-aligned (blue bubble)&#10;    // Label: &quot;You&quot;&#10;} else {&#10;    // Show left-aligned (gray bubble)&#10;    // Label: sender_name&#10;}&#10;```&#10;&#10;## Summary&#10;&#10;✅ **Inbox** - Shows OTHER people's names (who you're chatting with)&#10;✅ **Messages** - Shows WHO sent each message (actual sender)&#10;✅ **Conversation ID** - Groups all messages from same chat&#10;✅ **is_outgoing** - Distinguishes incoming vs outgoing messages&#10;✅ **Natural UX** - Works like WhatsApp/Messenger&#10;&#10;The system now perfectly mimics real messaging apps! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/EDITABLE_AI_REPLY_AND_ENHANCED_FILTERING.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/EDITABLE_AI_REPLY_AND_ENHANCED_FILTERING.md" />
              <option name="updatedContent" value="# Editable AI Reply &amp; Enhanced Summary Filtering - Implementation Complete&#10;&#10;## Changes Made&#10;&#10;### 1. ✅ Editable AI Reply with Send Button&#10;&#10;The AI-generated replies can now be edited before sending!&#10;&#10;#### What Changed:&#10;&#10;**Before:**&#10;```&#10;[AI Reply displayed as static text]&#10;[Send Button] ← Sends original AI reply&#10;```&#10;&#10;**After:**&#10;```&#10;[AI Reply in editable TextField]&#10;[Send Edit Button] ← Sends edited version&#10;```&#10;&#10;#### Implementation Details:&#10;&#10;**MessageBubble Component:**&#10;```kotlin&#10;// State for editable AI reply&#10;var editableReply by remember(message.ai_reply) { mutableStateOf(message.ai_reply) }&#10;var isEditing by remember { mutableStateOf(false) }&#10;&#10;// TextField for editing (when not sent)&#10;if (!message.is_sent) {&#10;    TextField(&#10;        value = editableReply,&#10;        onValueChange = { &#10;            editableReply = it&#10;            isEditing = true&#10;        },&#10;        // Styled with green background to match AI theme&#10;    )&#10;} else {&#10;    // Read-only Text (after sent)&#10;    Text(text = message.ai_reply)&#10;}&#10;```&#10;&#10;**Send Button:**&#10;```kotlin&#10;Button(&#10;    onClick = { onSendReply(editableReply) }, // ← Passes edited text&#10;    text = if (isEditing) &quot;Send Edit&quot; else &quot;Send&quot;&#10;)&#10;```&#10;&#10;#### Features:&#10;&#10;✅ **Editable TextField** - Click to edit AI reply&#10;✅ **Multi-line support** - 2-6 lines for longer replies&#10;✅ **Visual feedback** - Button shows &quot;Send Edit&quot; when modified&#10;✅ **Green theme** - Matches AI reply card color&#10;✅ **Auto-save** - Edited text is preserved&#10;✅ **Read-only after sent** - Can't edit after sending&#10;&#10;#### User Flow:&#10;&#10;1. Click &quot;Generate Reply&quot; → AI generates response&#10;2. **AI reply appears in editable TextField**&#10;3. Click inside → Edit the text as needed&#10;4. Button changes to **&quot;Send Edit&quot;**&#10;5. Click Send → Edited version is sent&#10;6. After sending → Reply becomes read-only&#10;&#10;### 2. ✅ Enhanced WhatsApp Summary Filtering&#10;&#10;Added more patterns to filter out WhatsApp summary notifications.&#10;&#10;#### New Patterns Added:&#10;&#10;**Pattern 4: &quot;X messages from X chats&quot;**&#10;```&#10;✅ Filtered: &quot;2 messages from 2 chats&quot;&#10;✅ Filtered: &quot;5 messages from 3 chats&quot;&#10;✅ Filtered: &quot;10 messages from 5 chats&quot;&#10;```&#10;&#10;**Pattern 5: &quot;X new messages from X chats&quot;**&#10;```&#10;✅ Filtered: &quot;2 new messages from 2 chats&quot;&#10;✅ Filtered: &quot;3 new messages from 1 chat&quot;&#10;✅ Filtered: &quot;10 new messages from 5 chats&quot;&#10;```&#10;&#10;#### Complete Filter List:&#10;&#10;| Pattern | Example | Status |&#10;|---------|---------|--------|&#10;| X new messages | &quot;2 new messages&quot; | ✅ Filtered |&#10;| X messages | &quot;4 messages&quot; | ✅ Filtered |&#10;| X new messages from... | &quot;3 new messages from Work&quot; | ✅ Filtered |&#10;| X messages from X chats | &quot;2 messages from 2 chats&quot; | ✅ **NEW** |&#10;| X new messages from X chats | &quot;3 new messages from 1 chat&quot; | ✅ **NEW** |&#10;&#10;#### What Gets Stored Now:&#10;&#10;✅ **Real Messages:**&#10;- &quot;Hey, how are you?&quot;&#10;- &quot;See you tomorrow!&quot;&#10;- &quot;k xa bro?&quot;&#10;&#10;❌ **Filtered Out (Summaries):**&#10;- &quot;2 messages&quot; ← Counter&#10;- &quot;3 new messages&quot; ← Counter&#10;- &quot;2 messages from 2 chats&quot; ← Multi-chat counter&#10;- &quot;5 new messages from 3 chats&quot; ← Multi-chat counter&#10;&#10;## Visual Examples&#10;&#10;### Editable AI Reply Flow&#10;&#10;```&#10;┌────────────────────────────────┐&#10;│  ┌─────────────────────┐       │&#10;│  │ Biplov Gautam       │       │  ← Incoming message&#10;│  │ Are you free today? │       │&#10;│  │ 14:30               │       │&#10;│  └─────────────────────┘       │&#10;│  [Generate Reply]               │  ← Step 1: Click&#10;├────────────────────────────────┤&#10;│      ┌─────────────────────┐   │&#10;│      │ ✨ AI Reply         │   │  ← Step 2: AI generates&#10;│      │ ┌─────────────────┐ │   │&#10;│      │ │ Yeah, after 4pm │ │   │  ← Step 3: Edit here!&#10;│      │ │ I'm free        │ │   │&#10;│      │ └─────────────────┘ │   │  (Editable TextField)&#10;│      └─────────────────────┘   │&#10;│      [Send Edit] ←───────────────  Step 4: Click to send&#10;└────────────────────────────────┘&#10;```&#10;&#10;### After Editing:&#10;&#10;```&#10;User edits reply to: &quot;Yeah bro, free after 5pm&quot;&#10;&#10;┌────────────────────────────────┐&#10;│      ┌─────────────────────┐   │&#10;│      │ ✨ AI Reply         │   │&#10;│      │ ┌─────────────────┐ │   │&#10;│      │ │ Yeah bro, free  │ │   │  ← Custom edit&#10;│      │ │ after 5pm       │ │   │&#10;│      │ └─────────────────┘ │   │&#10;│      └─────────────────────┘   │&#10;│      [Send Edit] ←───────────────  Ready to send&#10;└────────────────────────────────┘&#10;```&#10;&#10;### After Sending:&#10;&#10;```&#10;┌────────────────────────────────┐&#10;│      ┌─────────────────────┐   │&#10;│      │ ✨ AI Reply      ✓  │   │  ← Checkmark shown&#10;│      │ Yeah bro, free after│   │&#10;│      │ 5pm                 │   │  ← Now read-only&#10;│      └─────────────────────┘   │&#10;│      (No buttons - already sent)&#10;└────────────────────────────────┘&#10;```&#10;&#10;## Technical Implementation&#10;&#10;### MessageBubble State Management&#10;&#10;```kotlin&#10;@Composable&#10;fun MessageBubble(...) {&#10;    // Remember edited text per message&#10;    var editableReply by remember(message.ai_reply) { &#10;        mutableStateOf(message.ai_reply) &#10;    }&#10;    &#10;    // Track if user made edits&#10;    var isEditing by remember { &#10;        mutableStateOf(false) &#10;    }&#10;    &#10;    // TextField updates both states&#10;    TextField(&#10;        value = editableReply,&#10;        onValueChange = { &#10;            editableReply = it        // Update text&#10;            isEditing = true          // Mark as edited&#10;        }&#10;    )&#10;    &#10;    // Send button passes edited text&#10;    Button(&#10;        onClick = { onSendReply(editableReply) }&#10;    )&#10;}&#10;```&#10;&#10;### Summary Filter Regex&#10;&#10;```kotlin&#10;// Pattern 4: &quot;2 messages from 2 chats&quot;&#10;val summaryPattern4 = Regex(&quot;^\\d+\\s+messages?\\s+from\\s+\\d+\\s+chats?$&quot;)&#10;&#10;// Pattern 5: &quot;3 new messages from 1 chat&quot;&#10;val summaryPattern5 = Regex(&quot;^\\d+\\s+new\\s+messages?\\s+from\\s+\\d+\\s+chats?$&quot;)&#10;```&#10;&#10;## Benefits&#10;&#10;### Editable AI Reply:&#10;&#10;✅ **User Control** - Can fix AI mistakes or adjust tone&#10;✅ **Personalization** - Add personal touches to AI replies&#10;✅ **Flexibility** - No need to regenerate if almost correct&#10;✅ **Time-saving** - Quick edits vs full regeneration&#10;✅ **Natural workflow** - Like editing a draft message&#10;&#10;### Enhanced Filtering:&#10;&#10;✅ **Cleaner conversations** - No more summary clutter&#10;✅ **Accurate unread counts** - Only real messages count&#10;✅ **Better AI context** - AI doesn't see &quot;2 from 2 chats&quot; as content&#10;✅ **Storage efficiency** - Don't waste space on counters&#10;&#10;## Testing&#10;&#10;### Test Editable Reply:&#10;&#10;1. ✅ Receive WhatsApp message&#10;2. ✅ Open Smart Notifications → Conversation&#10;3. ✅ Click &quot;Generate Reply&quot;&#10;4. ✅ Click inside AI reply → Edit text&#10;5. ✅ Button changes to &quot;Send Edit&quot;&#10;6. ✅ Click Send → Edited version sent&#10;7. ✅ Reply becomes read-only after sending&#10;&#10;### Test Summary Filter:&#10;&#10;**Should Filter:**&#10;- &quot;2 messages from 2 chats&quot; ✅&#10;- &quot;3 new messages from 1 chat&quot; ✅&#10;- &quot;5 messages from 3 chats&quot; ✅&#10;&#10;**Should NOT Filter:**&#10;- &quot;Hey, 2 messages from John&quot; ❌ (actual content)&#10;- &quot;Check your chats&quot; ❌ (actual content)&#10;&#10;## Status&#10;&#10;✅ **Editable AI reply implemented**&#10;✅ **TextField with green theme styling**&#10;✅ **Send button shows &quot;Send Edit&quot; when modified**&#10;✅ **Multi-line support (2-6 lines)**&#10;✅ **Read-only after sending**&#10;✅ **WhatsApp multi-chat summaries filtered**&#10;✅ **Pattern 4 &amp; 5 added to filter**&#10;✅ **No compilation errors**&#10;&#10;Both features are now working! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/GROQ_API_KEY_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/GROQ_API_KEY_SETUP.md" />
              <option name="updatedContent" value="# Groq API Key Configuration - Complete Guide&#10;&#10;## Overview&#10;&#10;The Jawafai app uses the **same Groq API key** for both:&#10;1. **ChatBot conversations** (companion AI chat)&#10;2. **Notification AI replies** (smart messaging)&#10;&#10;This ensures consistent AI behavior and simplifies configuration.&#10;&#10;## API Key Location&#10;&#10;### Single Source of Truth: `local.properties`&#10;&#10;```ini&#10;# /Users/biplovgautam/Desktop/projects/jawafai/local.properties&#10;groq.apiKey=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&#10;```&#10;&#10;**Important:** This file is **NOT** committed to version control (in `.gitignore`)&#10;&#10;## How It Works&#10;&#10;### 1. Build Configuration (`app/build.gradle.kts`)&#10;&#10;```kotlin&#10;buildConfigField(&#10;    &quot;String&quot;, &#10;    &quot;GROQ_API_KEY&quot;, &#10;    &quot;\&quot;${localProperties.getProperty(&quot;groq.apiKey&quot;)}\&quot;&quot;&#10;)&#10;```&#10;&#10;This reads `groq.apiKey` from `local.properties` and creates `BuildConfig.GROQ_API_KEY`&#10;&#10;### 2. GroqApiManager Usage&#10;&#10;```kotlin&#10;object GroqApiManager {&#10;    private val GROQ_API_KEY = BuildConfig.GROQ_API_KEY&#10;    &#10;    // Used for chatbot&#10;    suspend fun getChatBotResponse(...) {&#10;        // Uses GROQ_API_KEY&#10;    }&#10;    &#10;    // Used for notifications&#10;    suspend fun getNotificationReply(...) {&#10;        // Uses GROQ_API_KEY (same key!)&#10;    }&#10;}&#10;```&#10;&#10;### 3. Both Features Use Same Manager&#10;&#10;**ChatBot Screen:**&#10;```kotlin&#10;val response = GroqApiManager.getChatBotResponse(&#10;    userMessage = message,&#10;    conversationHistory = history&#10;)&#10;```&#10;&#10;**Notification AI Reply:**&#10;```kotlin&#10;val response = GroqApiManager.getNotificationReply(&#10;    currentMessage = notification.text,&#10;    senderName = sender,&#10;    appName = &quot;WhatsApp&quot;,&#10;    conversationHistory = history&#10;)&#10;```&#10;&#10;## Flow Diagram&#10;&#10;```&#10;local.properties&#10;    groq.apiKey = &quot;gsk_...&quot;&#10;         ↓&#10;build.gradle.kts&#10;    Reads property&#10;         ↓&#10;BuildConfig.GROQ_API_KEY&#10;    Generated constant&#10;         ↓&#10;GroqApiManager&#10;    private val GROQ_API_KEY&#10;         ↓&#10;    ┌────────────────┴────────────────┐&#10;    ↓                                 ↓&#10;getChatBotResponse()        getNotificationReply()&#10;    ↓                                 ↓&#10;ChatBot Feature            Notification AI Reply&#10;```&#10;&#10;## Current Configuration&#10;&#10;### API Key&#10;```&#10;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&#10;```&#10;&#10;### Model&#10;```&#10;llama-3.3-70b-versatile&#10;```&#10;&#10;### Settings&#10;```kotlin&#10;MAX_TOKENS = 2048&#10;TEMPERATURE = 0.7&#10;MAX_CONVERSATION_HISTORY = 10&#10;```&#10;&#10;## Validation&#10;&#10;### API Key Check&#10;&#10;```kotlin&#10;fun isApiKeyConfigured(): Boolean {&#10;    return GROQ_API_KEY != &quot;gsk_your_groq_api_key_here&quot; &#10;        &amp;&amp; validateApiKey(GROQ_API_KEY)&#10;}&#10;&#10;fun validateApiKey(apiKey: String): Boolean {&#10;    return apiKey.startsWith(&quot;gsk_&quot;) &amp;&amp; apiKey.length &gt; 10&#10;}&#10;```&#10;&#10;### Usage in NotificationScreen&#10;&#10;```kotlin&#10;if (!GroqApiManager.isApiKeyConfigured()) {&#10;    Toast.makeText(context, &quot;Error: API key not configured&quot;, Toast.LENGTH_LONG).show()&#10;    return&#10;}&#10;```&#10;&#10;## Benefits of Single API Key&#10;&#10;### ✅ Simplified Configuration&#10;- One place to update (`local.properties`)&#10;- No duplication&#10;- Easier maintenance&#10;&#10;### ✅ Consistent Behavior&#10;- Same model for both features&#10;- Same temperature/settings&#10;- Unified AI personality&#10;&#10;### ✅ Cost Management&#10;- Single Groq account&#10;- Unified rate limits&#10;- Easier to track usage&#10;&#10;### ✅ Security&#10;- Single secret to protect&#10;- Not committed to Git&#10;- Managed through BuildConfig&#10;&#10;## Troubleshooting&#10;&#10;### Issue 1: &quot;API key not configured&quot;&#10;&#10;**Cause:** Missing or incorrect property name in `local.properties`&#10;&#10;**Fix:**&#10;```ini&#10;# Wrong (old format)&#10;GROQ_API_KEY=gsk_...&#10;&#10;# Correct (new format)&#10;groq.apiKey=gsk_...&#10;```&#10;&#10;### Issue 2: BuildConfig.GROQ_API_KEY is null&#10;&#10;**Cause:** Need to rebuild after changing `local.properties`&#10;&#10;**Fix:**&#10;```bash&#10;./gradlew clean&#10;./gradlew build&#10;```&#10;&#10;Or in Android Studio: Build → Rebuild Project&#10;&#10;### Issue 3: &quot;Invalid API key&quot;&#10;&#10;**Cause:** API key doesn't start with &quot;gsk_&quot; or is too short&#10;&#10;**Fix:**&#10;1. Verify key from Groq Console: https://console.groq.com/keys&#10;2. Ensure format: `gsk_&lt;40+ characters&gt;`&#10;3. Update `local.properties`&#10;4. Rebuild project&#10;&#10;### Issue 4: Different keys in different files&#10;&#10;**Wrong Approach:**&#10;```kotlin&#10;// ❌ Don't hardcode in GroqApiManager.kt&#10;private val GROQ_API_KEY = &quot;gsk_...&quot;&#10;&#10;// ❌ Don't hardcode in NotificationAIReplyManager.kt&#10;private const val API_KEY = &quot;gsk_...&quot;&#10;```&#10;&#10;**Correct Approach:**&#10;```kotlin&#10;// ✅ Always use BuildConfig&#10;private val GROQ_API_KEY = BuildConfig.GROQ_API_KEY&#10;```&#10;&#10;## Security Best Practices&#10;&#10;### ✅ Do's&#10;1. Store in `local.properties` (gitignored)&#10;2. Use BuildConfig for access&#10;3. Never commit API keys to Git&#10;4. Rotate keys periodically&#10;5. Use different keys for dev/prod if needed&#10;&#10;### ❌ Don'ts&#10;1. Hardcode in source files&#10;2. Commit to version control&#10;3. Share in chat/email&#10;4. Include in screenshots&#10;5. Store in plain text files that get committed&#10;&#10;## API Key Rotation&#10;&#10;If you need to change the API key:&#10;&#10;1. **Get new key from Groq Console**&#10;   ```&#10;   https://console.groq.com/keys&#10;   ```&#10;&#10;2. **Update local.properties**&#10;   ```ini&#10;   groq.apiKey=gsk_NEW_KEY_HERE&#10;   ```&#10;&#10;3. **Rebuild project**&#10;   ```bash&#10;   ./gradlew clean&#10;   ./gradlew build&#10;   ```&#10;&#10;4. **Test both features**&#10;   - ChatBot: Send a test message&#10;   - Notifications: Generate AI reply&#10;&#10;## Verification&#10;&#10;To verify the API key is working:&#10;&#10;### 1. ChatBot Test&#10;```&#10;1. Open app&#10;2. Go to ChatBot screen&#10;3. Send message: &quot;Hello&quot;&#10;4. Should get AI response&#10;```&#10;&#10;### 2. Notification Test&#10;```&#10;1. Receive WhatsApp message&#10;2. Open Notifications tab&#10;3. Click conversation&#10;4. Click &quot;Generate Reply&quot;&#10;5. Should see AI-generated reply&#10;```&#10;&#10;### 3. Check Logs&#10;```bash&#10;adb logcat | grep &quot;GroqApiManager&quot;&#10;```&#10;&#10;Expected output:&#10;```&#10;✅ API key configured&#10;✅ Sending request to Groq API...&#10;✅ Response received successfully&#10;```&#10;&#10;## Summary&#10;&#10;✅ **Single API key** used for both ChatBot and Notifications&#10;✅ **Stored in** `local.properties` (not committed)&#10;✅ **Accessed via** `BuildConfig.GROQ_API_KEY`&#10;✅ **Managed by** `GroqApiManager`&#10;✅ **Current key:** `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`&#10;✅ **Model:** `llama-3.3-70b-versatile`&#10;&#10;**Both features are now using the same Groq API key!** &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/NOTIFICATION_MANAGEMENT.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/NOTIFICATION_MANAGEMENT.md" />
              <option name="updatedContent" value="# Notification Management System - Current Implementation&#10;&#10;## Overview&#10;The notification system uses an **in-memory store** (NotificationMemoryStore) to manage notifications efficiently without database overhead. This is perfect for the current use case since notifications are temporary by nature.&#10;&#10;## Current Structure&#10;&#10;### 1. NotificationMemoryStore (Service Layer)&#10;**Location:** `/app/src/main/java/com/example/jawafai/service/NotificationMemoryStore.kt`&#10;&#10;**Data Structure:**&#10;```kotlin&#10;data class ExternalNotification(&#10;    val title: String,                    // Group name or sender&#10;    val text: String,                     // Message content&#10;    val packageName: String,              // App package name (e.g., &quot;com.whatsapp&quot;)&#10;    val time: Long,                       // Timestamp in milliseconds&#10;    val sender: String? = null,           // Actual sender name&#10;    val conversationTitle: String? = null, // For group chats&#10;    val conversationId: String,           // Unique conversation identifier&#10;    val hasReplyAction: Boolean = false,  // Whether reply action is available&#10;    val replyAction: Notification.Action? = null,&#10;    val remoteInput: RemoteInput? = null,&#10;    val hash: String,                     // For deduplication&#10;    val ai_reply: String = &quot;&quot;,            // AI generated reply&#10;    val is_sent: Boolean = false,         // Whether reply was sent&#10;    val rawExtras: Map&lt;String, String&gt; = emptyMap() // ALL raw notification extras&#10;)&#10;```&#10;&#10;**Key Features:**&#10;- ✅ In-memory storage using Compose's `mutableStateListOf`&#10;- ✅ Automatic deduplication using hash&#10;- ✅ Size limit of 500 notifications to prevent memory issues&#10;- ✅ Conversation-based grouping via `conversationId`&#10;- ✅ Complete raw extras storage for pattern analysis&#10;&#10;### 2. Timestamp Handling&#10;&#10;**Storage:** Timestamps are stored as `Long` (milliseconds since epoch)&#10;&#10;**Display Formats:**&#10;&#10;#### A. Smart Tab (User-Friendly)&#10;- &quot;now&quot; - less than 1 minute ago&#10;- &quot;5m ago&quot; - minutes ago&#10;- &quot;2h ago&quot; - hours ago&#10;- &quot;yesterday&quot; - 24-48 hours ago&#10;- &quot;Jan 15&quot; - older dates&#10;&#10;#### B. Raw Tab (Analysis)&#10;- **Processed Fields:**&#10;  - `Timestamp (Formatted)`: &quot;2026-02-12 14:30:45&quot; (yyyy-MM-dd HH:mm:ss)&#10;  - `Timestamp (Raw)`: &quot;1770851045221&quot; (milliseconds)&#10;  &#10;- **JSON Structure:**&#10;```json&#10;{&#10;  &quot;timestamp&quot;: 1770851045221,&#10;  &quot;timestamp_formatted&quot;: &quot;2026-02-12 14:30:45&quot;,&#10;  ...&#10;}&#10;```&#10;&#10;### 3. Conversation Management&#10;&#10;The system automatically groups messages into conversations using `conversationId`:&#10;&#10;**Conversation ID Generation Logic:**&#10;1. Uses notification key if available&#10;2. Falls back to: `packageName_title_sender` hash&#10;&#10;**Conversation Methods:**&#10;- `getConversationContext()` - Get last N messages in a conversation&#10;- `getNotificationsByConversation()` - Get all messages in a conversation&#10;&#10;### 4. Message Storage Pattern&#10;&#10;While we use in-memory storage, the data model maps to your analyst dashboard structure:&#10;&#10;**Virtual Table 1: Conversations (In-Memory)**&#10;```&#10;conversationId     -&gt; convo_id&#10;packageName        -&gt; package_name&#10;sender/title       -&gt; display_name&#10;time               -&gt; last_msg_time&#10;```&#10;&#10;**Virtual Table 2: Messages (In-Memory)**&#10;```&#10;hash               -&gt; msg_id (deduplication)&#10;conversationId     -&gt; convo_id (FK)&#10;sender             -&gt; sender_name&#10;text               -&gt; msg_content&#10;time               -&gt; timestamp&#10;```&#10;&#10;## Why In-Memory Instead of Database?&#10;&#10;### Advantages:&#10;1. **Performance:** Instant access, no disk I/O&#10;2. **Simplicity:** No database migrations or schema changes&#10;3. **Privacy:** Data is cleared when app closes&#10;4. **Real-time:** Compose state automatically updates UI&#10;5. **Sufficient:** 500 notifications limit is more than enough&#10;&#10;### When to Consider Database:&#10;- If you need **persistent** conversation history&#10;- If you want to **analyze patterns** across app restarts&#10;- If you want to implement **conversation backups**&#10;&#10;## Notification Flow&#10;&#10;```&#10;1. Android System&#10;   ↓&#10;2. JawafaiNotificationListenerService&#10;   ↓ (extracts data + raw extras)&#10;3. NotificationMemoryStore.addNotification()&#10;   ↓ (deduplication + grouping)&#10;4. UI (NotificationScreen)&#10;   ├─ Smart Tab: User-friendly view&#10;   └─ Raw Tab: Complete data with timestamps&#10;```&#10;&#10;## Raw Data Access&#10;&#10;The Raw tab now shows:&#10;1. **Processed Fields** - Structured data we extract&#10;2. **Raw Notification Extras** - ALL Android notification fields&#10;3. **Complete JSON** - Copyable JSON with both raw and formatted timestamps&#10;&#10;### Example JSON Output:&#10;```json&#10;{&#10;  &quot;title&quot;: &quot;Biplov Gautam&quot;,&#10;  &quot;text&quot;: &quot;hellooo&quot;,&#10;  &quot;packageName&quot;: &quot;com.whatsapp&quot;,&#10;  &quot;timestamp&quot;: 1770851045221,&#10;  &quot;timestamp_formatted&quot;: &quot;2026-02-12 14:30:45&quot;,&#10;  &quot;sender&quot;: &quot;Biplov Gautam&quot;,&#10;  &quot;conversationTitle&quot;: null,&#10;  &quot;conversationId&quot;: &quot;com.whatsapp_170762839&quot;,&#10;  &quot;hasReplyAction&quot;: true,&#10;  &quot;ai_reply&quot;: &quot;Hey! What's up?&quot;,&#10;  &quot;is_sent&quot;: false,&#10;  &quot;hash&quot;: &quot;843f...07f1&quot;,&#10;  &quot;rawExtras&quot;: {&#10;    &quot;android.title&quot;: &quot;Biplov Gautam&quot;,&#10;    &quot;android.text&quot;: &quot;hellooo&quot;,&#10;    &quot;android.subText&quot;: &quot;WhatsApp&quot;,&#10;    ...all other Android fields...&#10;  }&#10;}&#10;```&#10;&#10;## Future Enhancements (When Needed)&#10;&#10;If you later need persistent storage, the database structure is ready:&#10;&#10;### Table 1: conversations&#10;```sql&#10;convo_id (PK)        TEXT    -- e.g., &quot;com.whatsapp_170762839&quot;&#10;package_name         TEXT    -- e.g., &quot;com.whatsapp&quot;&#10;display_name         TEXT    -- e.g., &quot;Biplov Gautam&quot;&#10;last_msg_time        INTEGER -- Milliseconds timestamp&#10;platform_id          TEXT    -- Optional specific ID&#10;```&#10;&#10;### Table 2: messages&#10;```sql&#10;msg_id (PK)          INTEGER -- Auto-increment&#10;convo_id (FK)        TEXT    -- Links to conversations&#10;sender_name          TEXT    -- Who sent this message&#10;msg_content          TEXT    -- The text&#10;timestamp            INTEGER -- Milliseconds&#10;is_outgoing          BOOLEAN -- True if from user&#10;msg_hash             TEXT    -- Deduplication&#10;```&#10;&#10;## Current Status&#10;&#10;✅ **In-memory storage working perfectly**&#10;✅ **Timestamps stored accurately (milliseconds)**&#10;✅ **Both raw and formatted timestamps available**&#10;✅ **Complete raw data captured**&#10;✅ **Copyable JSON for analysis**&#10;✅ **No data loss or timestamp conversion issues**&#10;&#10;The system is production-ready without requiring a database at this stage!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/RAW_NOTIFICATION_DATA.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/RAW_NOTIFICATION_DATA.md" />
              <option name="updatedContent" value="# Raw Notification Data - Complete Implementation&#10;&#10;## What's Now Truly RAW&#10;&#10;The Raw tab in the Notifications screen now displays **COMPLETELY RAW** notification data without any filtering or processing.&#10;&#10;### Changes Made:&#10;&#10;1. **NotificationMemoryStore.kt**&#10;   - Added `rawExtras: Map&lt;String, String&gt;` field to `ExternalNotification` data class&#10;   - This captures ALL fields from the Android notification extras Bundle&#10;&#10;2. **JawafaiNotificationListenerService.kt**&#10;   - Modified `extractNotificationData()` to capture ALL extras from the notification Bundle&#10;   - Every single key-value pair from `notification.extras.keySet()` is now stored&#10;   - Handles different data types (CharSequence, Array, etc.)&#10;&#10;3. **NotificationScreen.kt (Raw Tab)**&#10;   - Displays two sections:&#10;     - **Processed Fields**: The structured data we extract (title, text, sender, etc.)&#10;     - **Raw Notification Extras**: ALL the raw fields from the Android notification Bundle&#10;   - Shows a count of how many raw extras fields were captured&#10;   - Includes complete JSON structure with all raw extras&#10;&#10;### What You'll See in the Raw Tab:&#10;&#10;#### Processed Fields (Our structured data):&#10;- Title&#10;- Text&#10;- Package Name&#10;- Timestamp&#10;- Sender&#10;- Conversation Title&#10;- Conversation ID&#10;- Has Reply Action&#10;- AI Reply&#10;- Is Sent&#10;- Full Hash&#10;&#10;#### Raw Notification Extras (EVERYTHING from Android):&#10;This section shows ALL fields that Android includes in the notification, which may include:&#10;- `android.title`&#10;- `android.text`&#10;- `android.subText`&#10;- `android.conversationTitle`&#10;- `android.largeIcon`&#10;- `android.messages` (for messaging notifications)&#10;- `android.person` (for person info)&#10;- `android.remoteInputHistory`&#10;- `android.showWhen`&#10;- `android.showChronometer`&#10;- `android.messagingUser`&#10;- And many more app-specific fields...&#10;&#10;### Why This Is Important:&#10;&#10;Different messaging apps (WhatsApp, Instagram, Messenger) may include different custom fields in their notifications. By capturing ALL raw extras, you can:&#10;&#10;1. **Analyze patterns** - See what fields different apps use&#10;2. **Find hidden data** - Discover fields we're not currently using&#10;3. **Debug issues** - See exactly what Android is giving us&#10;4. **Improve extraction** - Identify better ways to extract sender names, message content, etc.&#10;&#10;### JSON Structure:&#10;&#10;The Raw tab now shows a complete JSON representation including:&#10;```json&#10;{&#10;  &quot;title&quot;: &quot;...&quot;,&#10;  &quot;text&quot;: &quot;...&quot;,&#10;  &quot;packageName&quot;: &quot;...&quot;,&#10;  &quot;rawExtras&quot;: {&#10;    &quot;android.title&quot;: &quot;...&quot;,&#10;    &quot;android.text&quot;: &quot;...&quot;,&#10;    &quot;android.subText&quot;: &quot;...&quot;,&#10;    &quot;android.conversationTitle&quot;: &quot;...&quot;,&#10;    ...all other fields...&#10;  }&#10;}&#10;```&#10;&#10;## Usage:&#10;&#10;1. Navigate to **Notifications** screen&#10;2. Switch to the **Raw** tab&#10;3. Tap on any notification card to expand it&#10;4. Scroll through the **Raw Notification Extras** section to see ALL fields&#10;5. Compare different apps to see pattern differences&#10;&#10;This is now **COMPLETELY RAW** - nothing is filtered or left out!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/SUMMARY_NOTIFICATION_FILTERING.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/SUMMARY_NOTIFICATION_FILTERING.md" />
              <option name="updatedContent" value="# WhatsApp Summary Notification Filtering&#10;&#10;## Problem&#10;&#10;WhatsApp sends two types of notifications:&#10;&#10;1. **Actual Messages** - Real message content&#10;   - Example: &quot;Hey, how are you?&quot;&#10;   - Example: &quot;See you tomorrow!&quot;&#10;&#10;2. **Summary Notifications** - Just counters (not actual messages)&#10;   - Example: &quot;2 new messages&quot;&#10;   - Example: &quot;4 messages&quot;&#10;   - Example: &quot;3 new messages from Work Group&quot;&#10;&#10;**Issue:** Summary notifications were being stored as if they were real messages, cluttering the conversation view.&#10;&#10;## Solution&#10;&#10;Added `isSummaryNotification()` filter to detect and skip these counter notifications.&#10;&#10;## Detection Patterns&#10;&#10;The filter detects these patterns:&#10;&#10;### Pattern 1: &quot;X new messages&quot; or &quot;X messages&quot;&#10;```&#10;✅ Filtered: &quot;2 new messages&quot;&#10;✅ Filtered: &quot;4 messages&quot;&#10;✅ Filtered: &quot;1 message&quot;&#10;✅ Filtered: &quot;10 new messages&quot;&#10;❌ Not filtered: &quot;Hey, check your messages&quot; (actual content)&#10;```&#10;&#10;**Regex:** `^\d+\s+(new\s+)?messages?$`&#10;&#10;### Pattern 2: &quot;X new messages from...&quot;&#10;```&#10;✅ Filtered: &quot;3 new messages from Work Group&quot;&#10;✅ Filtered: &quot;5 new messages from Family&quot;&#10;✅ Filtered: &quot;2 new messages from John&quot;&#10;❌ Not filtered: &quot;I got 3 new messages from John today&quot; (actual content)&#10;```&#10;&#10;**Regex:** `^\d+\s+new\s+messages?\s+from.*`&#10;&#10;### Pattern 3: Single/Double digit + &quot;messages&quot;&#10;```&#10;✅ Filtered: &quot;2 messages&quot;&#10;✅ Filtered: &quot;15 messages&quot;&#10;✅ Filtered: &quot;100 messages&quot;&#10;❌ Not filtered: &quot;I sent you some messages&quot; (actual content)&#10;```&#10;&#10;**Regex:** `^\d{1,3}\s+messages?$`&#10;&#10;## Implementation&#10;&#10;### NotificationMemoryStore.kt&#10;&#10;```kotlin&#10;private fun isSummaryNotification(text: String): Boolean {&#10;    val lowerText = text.lowercase().trim()&#10;    &#10;    // Pattern 1: &quot;X new messages&quot; or &quot;X messages&quot;&#10;    val summaryPattern1 = Regex(&quot;^\\d+\\s+(new\\s+)?messages?$&quot;)&#10;    if (summaryPattern1.matches(lowerText)) return true&#10;    &#10;    // Pattern 2: &quot;X new messages from...&quot; (group chat summary)&#10;    val summaryPattern2 = Regex(&quot;^\\d+\\s+new\\s+messages?\\s+from.*&quot;)&#10;    if (summaryPattern2.matches(lowerText)) return true&#10;    &#10;    // Pattern 3: Single digit followed by &quot;messages&quot;&#10;    if (lowerText.matches(Regex(&quot;^\\d{1,3}\\s+messages?$&quot;))) return true&#10;    &#10;    return false&#10;}&#10;&#10;fun addNotification(notification: ExternalNotification): Boolean {&#10;    // Skip WhatsApp summary notifications&#10;    if (isSummaryNotification(notification.text)) {&#10;        Log.d(&quot;NotificationMemoryStore&quot;, &quot;Skipping summary notification: ${notification.text}&quot;)&#10;        return false&#10;    }&#10;    &#10;    // ...rest of the logic&#10;}&#10;```&#10;&#10;## How It Works&#10;&#10;### Before Filtering&#10;&#10;```&#10;INBOX: Biplov Gautam&#10;├─ Message 1: &quot;Hey there!&quot;&#10;├─ Message 2: &quot;2 new messages&quot;  ← Summary (clutter)&#10;├─ Message 3: &quot;How are you?&quot;&#10;└─ Message 4: &quot;4 messages&quot;      ← Summary (clutter)&#10;```&#10;&#10;### After Filtering&#10;&#10;```&#10;INBOX: Biplov Gautam&#10;├─ Message 1: &quot;Hey there!&quot;      ← Actual message&#10;└─ Message 2: &quot;How are you?&quot;    ← Actual message&#10;&#10;Summary notifications filtered out! ✅&#10;```&#10;&#10;## Test Cases&#10;&#10;### ✅ Should Filter (Summaries)&#10;&#10;| Input | Match | Reason |&#10;|-------|-------|--------|&#10;| &quot;2 new messages&quot; | ✅ | Pattern 1 |&#10;| &quot;4 messages&quot; | ✅ | Pattern 1 |&#10;| &quot;1 message&quot; | ✅ | Pattern 1 |&#10;| &quot;10 new messages&quot; | ✅ | Pattern 1 |&#10;| &quot;3 new messages from Work&quot; | ✅ | Pattern 2 |&#10;| &quot;5 new messages from Family Group&quot; | ✅ | Pattern 2 |&#10;| &quot;15 messages&quot; | ✅ | Pattern 3 |&#10;| &quot;100 messages&quot; | ✅ | Pattern 3 |&#10;&#10;### ❌ Should NOT Filter (Real Messages)&#10;&#10;| Input | Match | Reason |&#10;|-------|-------|--------|&#10;| &quot;Hey, check your messages&quot; | ❌ | Actual message content |&#10;| &quot;I have 2 new messages for you&quot; | ❌ | Not at start |&#10;| &quot;Got messages from John&quot; | ❌ | No number |&#10;| &quot;messagesssss&quot; | ❌ | Not exact pattern |&#10;| &quot;new messages coming&quot; | ❌ | No number |&#10;| &quot;Check the 2 messages I sent&quot; | ❌ | Not at start |&#10;&#10;## Why Case-Insensitive?&#10;&#10;```kotlin&#10;val lowerText = text.lowercase().trim()&#10;```&#10;&#10;Handles variations:&#10;- &quot;2 New Messages&quot; ✅&#10;- &quot;4 MESSAGES&quot; ✅&#10;- &quot;3 new MESSAGES&quot; ✅&#10;- &quot;  2 messages  &quot; ✅ (with trim)&#10;&#10;## Logging&#10;&#10;When a summary notification is filtered:&#10;```&#10;D/NotificationMemoryStore: Skipping summary notification: 2 new messages&#10;```&#10;&#10;This helps with debugging and monitoring filter effectiveness.&#10;&#10;## Benefits&#10;&#10;### ✅ Cleaner Conversation View&#10;- Only real messages shown&#10;- No counter clutter&#10;&#10;### ✅ Accurate Message Count&#10;- Unread count reflects actual messages&#10;- Not inflated by summaries&#10;&#10;### ✅ Better AI Context&#10;- AI only sees real message content&#10;- No confusion from &quot;2 messages&quot; etc.&#10;&#10;### ✅ Storage Efficiency&#10;- Don't waste memory on counters&#10;- Only store meaningful content&#10;&#10;## Edge Cases Handled&#10;&#10;### 1. Group Chat Summaries&#10;```&#10;Input: &quot;3 new messages from Work Group&quot;&#10;Result: ✅ Filtered (Pattern 2)&#10;```&#10;&#10;### 2. Large Numbers&#10;```&#10;Input: &quot;100 messages&quot;&#10;Result: ✅ Filtered (Pattern 3)&#10;```&#10;&#10;### 3. Singular vs Plural&#10;```&#10;Input: &quot;1 message&quot;&#10;Result: ✅ Filtered (Pattern 1)&#10;Note: Regex uses `messages?` to handle both&#10;```&#10;&#10;### 4. Extra Whitespace&#10;```&#10;Input: &quot;  2 new messages  &quot;&#10;Result: ✅ Filtered (trim() removes spaces)&#10;```&#10;&#10;### 5. Mixed Case&#10;```&#10;Input: &quot;2 NEW MESSAGES&quot;&#10;Result: ✅ Filtered (lowercase() normalizes)&#10;```&#10;&#10;## Future Enhancements&#10;&#10;If WhatsApp changes notification format, add more patterns:&#10;&#10;```kotlin&#10;// Pattern 4: &quot;X unread messages&quot;&#10;val summaryPattern4 = Regex(&quot;^\\d+\\s+unread\\s+messages?$&quot;)&#10;&#10;// Pattern 5: &quot;You have X messages&quot;&#10;val summaryPattern5 = Regex(&quot;^you\\s+have\\s+\\d+\\s+messages?$&quot;)&#10;&#10;// Pattern 6: &quot;X more messages&quot;&#10;val summaryPattern6 = Regex(&quot;^\\d+\\s+more\\s+messages?$&quot;)&#10;```&#10;&#10;## Testing&#10;&#10;To verify filtering works:&#10;&#10;1. Receive multiple WhatsApp messages quickly&#10;2. WhatsApp should send summary notification (e.g., &quot;3 messages&quot;)&#10;3. Check logs: Should see &quot;Skipping summary notification: 3 messages&quot;&#10;4. Check conversation view: Should NOT show &quot;3 messages&quot; as a message&#10;5. Only actual message content should be visible&#10;&#10;## Status&#10;&#10;✅ **Summary detection implemented**&#10;✅ **Three pattern matchers active**&#10;✅ **Case-insensitive matching**&#10;✅ **Logging enabled for debugging**&#10;✅ **Preserves real message content**&#10;✅ **Filters group chat summaries**&#10;&#10;The conversation view is now clean of WhatsApp counter notifications! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/WHATSAPP_YOU_HANDLING.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/WHATSAPP_YOU_HANDLING.md" />
              <option name="updatedContent" value="# WhatsApp &quot;You&quot; Title Handling - Complete Guide&#10;&#10;## The Problem&#10;&#10;In WhatsApp notifications:&#10;- **Incoming message**: `title = &quot;Biplov Gautam&quot;` (sender's name)&#10;- **Outgoing message**: `title = &quot;You&quot;` (you sent it)&#10;&#10;We need to handle these differently so the inbox shows the OTHER person's name, not &quot;You&quot;.&#10;&#10;## The Solution&#10;&#10;### Detection Logic&#10;&#10;```kotlin&#10;val title = notification.title&#10;val is_outgoing = title.equals(&quot;You&quot;, ignoreCase = true)&#10;```&#10;&#10;### Behavior&#10;&#10;#### Case 1: Incoming Message (title ≠ &quot;You&quot;)&#10;```&#10;Notification:&#10;├─ title: &quot;Biplov Gautam&quot;&#10;├─ text: &quot;Hey, how are you?&quot;&#10;└─ is_outgoing: false&#10;&#10;Action:&#10;✅ Update conversation display_name to &quot;Biplov Gautam&quot;&#10;✅ Increment unread_count&#10;✅ Show message on LEFT (gray bubble)&#10;✅ Show sender name &quot;Biplov Gautam&quot; on message&#10;✅ Show &quot;Generate Reply&quot; button&#10;```&#10;&#10;#### Case 2: Outgoing Message (title = &quot;You&quot;)&#10;```&#10;Notification:&#10;├─ title: &quot;You&quot;&#10;├─ text: &quot;I'm good, thanks!&quot;&#10;└─ is_outgoing: true&#10;&#10;Action:&#10;✅ DON'T update conversation display_name (keep recipient's name)&#10;✅ DON'T increment unread_count&#10;✅ Show message on RIGHT (green bubble)&#10;✅ DON'T show sender name (it's &quot;You&quot;)&#10;✅ DON'T show &quot;Generate Reply&quot; button (you sent it!)&#10;```&#10;&#10;## Implementation&#10;&#10;### NotificationMemoryStore&#10;&#10;```kotlin&#10;private fun addToConversationStore(notification: ExternalNotification) {&#10;    val title = notification.title&#10;    val is_outgoing = title.equals(&quot;You&quot;, ignoreCase = true)&#10;    &#10;    val sender_name: String&#10;    val should_update_display_name: Boolean&#10;    &#10;    if (is_outgoing) {&#10;        // Outgoing: You sent the message&#10;        sender_name = &quot;You&quot;&#10;        should_update_display_name = false  // ← Keep recipient's name&#10;    } else {&#10;        // Incoming: Someone sent to you&#10;        sender_name = notification.sender ?: title&#10;        should_update_display_name = true  // ← Update to sender's name&#10;    }&#10;    &#10;    // Update conversation&#10;    if (existingConvoIndex != -1) {&#10;        conversations.add(0, existingConvo.copy(&#10;            last_msg_time = timestamp,&#10;            last_msg_content = msg_content,&#10;            unread_count = if (is_outgoing) existingConvo.unread_count else existingConvo.unread_count + 1,&#10;            display_name = if (should_update_display_name) sender_name else existingConvo.display_name  // ← Key logic&#10;        ))&#10;    }&#10;    &#10;    // Create message&#10;    val message = Message(&#10;        sender_name = sender_name,  // &quot;You&quot; or actual sender&#10;        is_outgoing = is_outgoing   // true if title=&quot;You&quot;&#10;    )&#10;}&#10;```&#10;&#10;### UI: MessageBubble&#10;&#10;```kotlin&#10;Row(&#10;    horizontalArrangement = if (message.is_outgoing) Arrangement.End else Arrangement.Start&#10;) {&#10;    Card(&#10;        shape = if (message.is_outgoing) {&#10;            RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp, bottomEnd = 4.dp, bottomStart = 16.dp)&#10;        } else {&#10;            RoundedCornerShape(topStart = 4.dp, topEnd = 16.dp, bottomEnd = 16.dp, bottomStart = 16.dp)&#10;        },&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (message.is_outgoing) &#10;                Color(0xFFDCF8C6)  // Green (like WhatsApp)&#10;            else &#10;                Color(0xFFF0F0F0)  // Gray&#10;        )&#10;    ) {&#10;        // Only show sender name for incoming&#10;        if (!message.is_outgoing) {&#10;            Text(text = message.sender_name)&#10;        }&#10;        &#10;        Text(text = message.msg_content)&#10;    }&#10;}&#10;&#10;// Action buttons - only for incoming&#10;if (!message.is_sent &amp;&amp; !message.is_outgoing) {&#10;    Button(onClick = onGenerateReply) {&#10;        Text(&quot;Generate Reply&quot;)&#10;    }&#10;}&#10;```&#10;&#10;## Visual Examples&#10;&#10;### Example 1: Conversation with Biplov&#10;&#10;#### Scenario: You receive 3 messages, then send 1 reply&#10;&#10;**Inbox:**&#10;```&#10;┌────────────────────────────────┐&#10;│ B  Biplov Gautam        2m ago │  ← Shows OTHER person&#10;│    WhatsApp                  [3]│  ← 3 unread (only incoming)&#10;│    I'm good too!               │  ← Last message (your reply)&#10;└────────────────────────────────┘&#10;```&#10;&#10;**Chat View:**&#10;```&#10;┌────────────────────────────────┐&#10;│ ← B  Biplov Gautam             │  ← Header: OTHER person&#10;│      WhatsApp                   │&#10;├────────────────────────────────┤&#10;│                                 │&#10;│  ┌─────────────────────┐       │  ← Incoming (LEFT, GRAY)&#10;│  │ Biplov Gautam       │       │&#10;│  │ Hey, how are you?   │       │&#10;│  │ 14:30               │       │&#10;│  └─────────────────────┘       │&#10;│  [Generate Reply]               │&#10;│                                 │&#10;│  ┌─────────────────────┐       │  ← Incoming (LEFT, GRAY)&#10;│  │ Biplov Gautam       │       │&#10;│  │ Long time no see!   │       │&#10;│  │ 14:31               │       │&#10;│  └─────────────────────┘       │&#10;│  [Generate Reply]               │&#10;│                                 │&#10;│  ┌─────────────────────┐       │  ← Incoming (LEFT, GRAY)&#10;│  │ Biplov Gautam       │       │&#10;│  │ What are you up to? │       │&#10;│  │ 14:32               │       │&#10;│  └─────────────────────┘       │&#10;│  [Generate Reply]               │&#10;│                                 │&#10;│      ┌─────────────────────┐   │  ← Outgoing (RIGHT, GREEN)&#10;│      │ I'm good too!       │   │  ← No sender name&#10;│      │ 14:33        ✓✓     │   │&#10;│      └─────────────────────┘   │  ← No buttons&#10;│                                 │&#10;└────────────────────────────────┘&#10;```&#10;&#10;### Data Flow&#10;&#10;#### Message 1: Incoming from Biplov&#10;```&#10;Notification:&#10;  title: &quot;Biplov Gautam&quot;&#10;  text: &quot;Hey, how are you?&quot;&#10;  &#10;↓ Processing ↓&#10;&#10;Conversation:&#10;  convo_id: &quot;com.whatsapp_170762839&quot;&#10;  display_name: &quot;Biplov Gautam&quot;  ✅ Updated&#10;  unread_count: 1  ✅ Incremented&#10;&#10;Message:&#10;  sender_name: &quot;Biplov Gautam&quot;&#10;  is_outgoing: false&#10;  ↓&#10;  UI: LEFT, GRAY, Show sender name, Show buttons&#10;```&#10;&#10;#### Message 2: Outgoing from You&#10;```&#10;Notification:&#10;  title: &quot;You&quot;&#10;  text: &quot;I'm good too!&quot;&#10;  &#10;↓ Processing ↓&#10;&#10;Conversation:&#10;  convo_id: &quot;com.whatsapp_170762839&quot;&#10;  display_name: &quot;Biplov Gautam&quot;  ✅ NOT updated (stays as is)&#10;  unread_count: 1  ✅ NOT incremented&#10;&#10;Message:&#10;  sender_name: &quot;You&quot;&#10;  is_outgoing: true&#10;  ↓&#10;  UI: RIGHT, GREEN, No sender name, No buttons&#10;```&#10;&#10;## Why This Matters&#10;&#10;### ✅ Correct Inbox Display&#10;- Inbox always shows the OTHER person's name&#10;- Never shows &quot;You&quot; as a conversation name&#10;- Matches WhatsApp behavior exactly&#10;&#10;### ✅ Correct Unread Count&#10;- Only incoming messages increment unread&#10;- Your own sent messages don't count as &quot;unread&quot;&#10;&#10;### ✅ Correct Message Display&#10;- Incoming: Left, gray, show sender&#10;- Outgoing: Right, green, hide sender&#10;- Matches messaging app conventions&#10;&#10;### ✅ Correct Actions&#10;- Generate Reply only for incoming messages&#10;- No buttons for your own sent messages&#10;&#10;## Edge Cases Handled&#10;&#10;### 1. First Message is Outgoing&#10;```&#10;If title=&quot;You&quot; and conversation doesn't exist:&#10;  Create conversation with display_name=&quot;Unknown&quot;&#10;  Will update to actual name when first incoming message arrives&#10;```&#10;&#10;### 2. Group Chats&#10;```&#10;Multiple incoming messages from different people:&#10;  Each message has different sender_name&#10;  Conversation display_name updates to latest sender&#10;  All non-&quot;You&quot; messages are incoming&#10;```&#10;&#10;### 3. Case Insensitive&#10;```&#10;title.equals(&quot;You&quot;, ignoreCase = true)&#10;  Handles: &quot;You&quot;, &quot;you&quot;, &quot;YOU&quot;, &quot;yOu&quot;&#10;```&#10;&#10;## Status&#10;&#10;✅ **Title=&quot;You&quot; detection working**&#10;✅ **Conversation display_name preserved**&#10;✅ **Unread count accurate**&#10;✅ **Message bubbles positioned correctly**&#10;✅ **Action buttons shown only for incoming**&#10;✅ **Visual styling matches WhatsApp**&#10;&#10;The system now perfectly handles WhatsApp's &quot;You&quot; title! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/database/NotificationDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/database/NotificationDatabase.kt" />
              <option name="updatedContent" value="package com.example.jawafai.database&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import com.example.jawafai.database.dao.ConversationDao&#10;import com.example.jawafai.database.dao.MessageDao&#10;import com.example.jawafai.database.entity.ConversationEntity&#10;import com.example.jawafai.database.entity.MessageEntity&#10;&#10;@Database(&#10;    entities = [ConversationEntity::class, MessageEntity::class],&#10;    version = 1,&#10;    exportSchema = false&#10;)&#10;abstract class NotificationDatabase : RoomDatabase() {&#10;    &#10;    abstract fun conversationDao(): ConversationDao&#10;    abstract fun messageDao(): MessageDao&#10;    &#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: NotificationDatabase? = null&#10;        &#10;        fun getDatabase(context: Context): NotificationDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    NotificationDatabase::class.java,&#10;                    &quot;notification_database&quot;&#10;                )&#10;                    .fallbackToDestructiveMigration()&#10;                    .build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/database/entity/ConversationEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/database/entity/ConversationEntity.kt" />
              <option name="updatedContent" value="package com.example.jawafai.database.entity&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;/**&#10; * Table 1: Conversations&#10; * Stores unique threads for the &quot;Inbox&quot; list&#10; */&#10;@Entity(tableName = &quot;conversations&quot;)&#10;data class ConversationEntity(&#10;    @PrimaryKey&#10;    val convo_id: String,              // e.g., &quot;com.whatsapp_170762839&quot;&#10;    val package_name: String,           // e.g., &quot;com.whatsapp&quot;&#10;    val display_name: String,           // e.g., &quot;Biplov Gautam&quot;&#10;    val last_msg_time: Long,           // Timestamp in milliseconds&#10;    val platform_id: String? = null    // Optional specific ID from extras&#10;) {&#10;    /**&#10;     * Get formatted timestamp for display&#10;     */&#10;    fun getFormattedTime(): String {&#10;        return SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())&#10;            .format(Date(last_msg_time))&#10;    }&#10;    &#10;    /**&#10;     * Get relative time (e.g., &quot;2 hours ago&quot;)&#10;     */&#10;    fun getRelativeTime(): String {&#10;        val now = System.currentTimeMillis()&#10;        val diff = now - last_msg_time&#10;        &#10;        return when {&#10;            diff &lt; 60 * 1000 -&gt; &quot;now&quot;&#10;            diff &lt; 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 1000)}m ago&quot;&#10;            diff &lt; 24 * 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 60 * 1000)}h ago&quot;&#10;            diff &lt; 48 * 60 * 60 * 1000 -&gt; &quot;yesterday&quot;&#10;            else -&gt; SimpleDateFormat(&quot;MMM dd&quot;, Locale.getDefault()).format(Date(last_msg_time))&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/service/JawafaiNotificationListenerService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/service/JawafaiNotificationListenerService.kt" />
              <option name="originalContent" value="package com.example.jawafai.service&#10;&#10;import android.service.notification.NotificationListenerService&#10;import android.service.notification.StatusBarNotification&#10;import android.content.Intent&#10;import android.content.BroadcastReceiver&#10;import android.content.IntentFilter&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager&#10;import android.content.Context&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.app.RemoteInput&#10;import android.app.Notification&#10;import android.app.PendingIntent&#10;import android.os.Bundle&#10;import kotlin.random.Random&#10;&#10;class JawafaiNotificationListenerService : NotificationListenerService() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;JawafaiNotifService&quot;&#10;        const val NOTIFICATION_BROADCAST_ACTION = &quot;com.example.jawafai.NOTIFICATION_LISTENER_EVENT&quot;&#10;        const val AI_REPLY_BROADCAST_ACTION = &quot;com.example.jawafai.AI_REPLY_REQUEST&quot;&#10;        const val REPLY_GENERATED_ACTION = &quot;com.example.jawafai.REPLY_GENERATED&quot;&#10;        const val REPLY_SENT_ACTION = &quot;com.example.jawafai.REPLY_SENT&quot;&#10;&#10;        // Define the package names of apps we want to capture notifications from&#10;        private val SUPPORTED_APPS = mapOf(&#10;            &quot;com.instagram.android&quot; to &quot;Instagram&quot;,&#10;            &quot;com.whatsapp&quot; to &quot;WhatsApp&quot;,&#10;            &quot;com.facebook.orca&quot; to &quot;Facebook Messenger&quot;,&#10;            &quot;com.whatsapp.w4b&quot; to &quot;WhatsApp Business&quot;,&#10;            &quot;com.facebook.katana&quot; to &quot;Facebook&quot;,&#10;            &quot;com.snapchat.android&quot; to &quot;Snapchat&quot;,&#10;            &quot;com.twitter.android&quot; to &quot;Twitter&quot;,&#10;            &quot;com.telegram.messenger&quot; to &quot;Telegram&quot;&#10;        )&#10;&#10;        // Utility to check if notification access is enabled&#10;        fun isNotificationAccessEnabled(context: Context): Boolean {&#10;            val enabledListeners = Settings.Secure.getString(&#10;                context.contentResolver,&#10;                &quot;enabled_notification_listeners&quot;&#10;            ) ?: return false&#10;            return enabledListeners.contains(context.packageName)&#10;        }&#10;    }&#10;&#10;    private val localBroadcastManager by lazy { LocalBroadcastManager.getInstance(this) }&#10;&#10;    // Broadcast receiver for handling AI-generated replies&#10;    private val replyReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                REPLY_GENERATED_ACTION -&gt; handleGeneratedReply(intent)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onListenerConnected() {&#10;        super.onListenerConnected()&#10;        Log.d(TAG, &quot;Smart Messaging Assistant connected!&quot;)&#10;&#10;        // Register broadcast receiver for AI replies&#10;        val filter = IntentFilter(REPLY_GENERATED_ACTION)&#10;        localBroadcastManager.registerReceiver(replyReceiver, filter)&#10;    }&#10;&#10;    override fun onListenerDisconnected() {&#10;        super.onListenerDisconnected()&#10;        Log.d(TAG, &quot;Smart Messaging Assistant disconnected!&quot;)&#10;&#10;        // Unregister broadcast receiver&#10;        try {&#10;            localBroadcastManager.unregisterReceiver(replyReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error unregistering receiver: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun isSupportedApp(packageName: String): Boolean {&#10;        return SUPPORTED_APPS.containsKey(packageName)&#10;    }&#10;&#10;    override fun onNotificationPosted(sbn: StatusBarNotification) {&#10;        val packageName = sbn.packageName ?: return&#10;&#10;        // Skip our own notifications and unsupported apps&#10;        if (packageName == this.packageName || !isSupportedApp(packageName)) {&#10;            Log.d(TAG, &quot;Notification ignored - not from supported app: $packageName&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(TAG, &quot;Processing notification from ${SUPPORTED_APPS[packageName]}&quot;)&#10;&#10;        try {&#10;            val smartNotification = extractNotificationData(sbn)&#10;&#10;            // Store notification with deduplication&#10;            val isNewNotification = NotificationMemoryStore.addNotification(smartNotification)&#10;&#10;            if (isNewNotification) {&#10;                Log.d(TAG, &quot;New notification stored: ${smartNotification.conversationId}&quot;)&#10;&#10;                // Broadcast to AI module if reply action is available&#10;                if (smartNotification.hasReplyAction) {&#10;                    triggerAIReplyGeneration(smartNotification)&#10;                }&#10;            } else {&#10;                Log.d(TAG, &quot;Duplicate notification ignored&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error processing notification: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract comprehensive notification data for smart messaging&#10;     */&#10;    private fun extractNotificationData(sbn: StatusBarNotification): NotificationMemoryStore.ExternalNotification {&#10;        val notification = sbn.notification&#10;        val extras = notification.extras&#10;        val packageName = sbn.packageName&#10;&#10;        // Extract basic notification fields&#10;        val title = extras.getString(Notification.EXTRA_TITLE) ?: &quot;(No Title)&quot;&#10;        val text = extras.getCharSequence(Notification.EXTRA_TEXT)?.toString() ?: &quot;(No Text)&quot;&#10;        val sender = extras.getString(Notification.EXTRA_SUB_TEXT)&#10;        val conversationTitle = extras.getString(Notification.EXTRA_CONVERSATION_TITLE)&#10;        val timestamp = sbn.postTime&#10;&#10;        // Generate conversation ID - use notification key or create custom one&#10;        val conversationId = generateConversationId(sbn, title, sender)&#10;&#10;        // Check for reply action and RemoteInput&#10;        val (hasReplyAction, replyAction, remoteInput) = extractReplyAction(notification)&#10;&#10;        // Generate hash for deduplication&#10;        val hash = NotificationMemoryStore.generateHash(title, text, packageName)&#10;&#10;        Log.d(TAG, &quot;Extracted notification data:&quot;)&#10;        Log.d(TAG, &quot;  Title: $title&quot;)&#10;        Log.d(TAG, &quot;  Text: $text&quot;)&#10;        Log.d(TAG, &quot;  Sender: $sender&quot;)&#10;        Log.d(TAG, &quot;  ConversationId: $conversationId&quot;)&#10;        Log.d(TAG, &quot;  HasReplyAction: $hasReplyAction&quot;)&#10;&#10;        return NotificationMemoryStore.ExternalNotification(&#10;            title = title,&#10;            text = text,&#10;            packageName = packageName,&#10;            time = timestamp,&#10;            sender = sender,&#10;            conversationTitle = conversationTitle,&#10;            conversationId = conversationId,&#10;            hasReplyAction = hasReplyAction,&#10;            replyAction = replyAction,&#10;            remoteInput = remoteInput,&#10;            hash = hash&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Generate unique conversation ID&#10;     */&#10;    private fun generateConversationId(sbn: StatusBarNotification, title: String, sender: String?): String {&#10;        // Try to use notification key first&#10;        val notificationKey = sbn.key&#10;        if (notificationKey.isNotBlank()) {&#10;            return &quot;${sbn.packageName}_${notificationKey.hashCode()}&quot;&#10;        }&#10;&#10;        // Fallback to combination of package, title, and sender&#10;        val identifier = &quot;${sbn.packageName}_${title}_${sender ?: &quot;unknown&quot;}&quot;&#10;        return identifier.hashCode().toString()&#10;    }&#10;&#10;    /**&#10;     * Extract reply action and RemoteInput from notification&#10;     */&#10;    private fun extractReplyAction(notification: Notification): Triple&lt;Boolean, Notification.Action?, RemoteInput?&gt; {&#10;        val actions = notification.actions ?: return Triple(false, null, null)&#10;&#10;        for (action in actions) {&#10;            val remoteInputs = action.remoteInputs&#10;            if (remoteInputs != null &amp;&amp; remoteInputs.isNotEmpty()) {&#10;                // Found reply action with RemoteInput&#10;                Log.d(TAG, &quot;Reply action found: ${action.title}&quot;)&#10;                return Triple(true, action, remoteInputs[0])&#10;            }&#10;        }&#10;&#10;        return Triple(false, null, null)&#10;    }&#10;&#10;    /**&#10;     * Trigger AI reply generation via broadcast&#10;     */&#10;    private fun triggerAIReplyGeneration(notification: NotificationMemoryStore.ExternalNotification) {&#10;        Log.d(TAG, &quot;Triggering AI reply generation for: ${notification.conversationId}&quot;)&#10;&#10;        val intent = Intent(AI_REPLY_BROADCAST_ACTION).apply {&#10;            putExtra(&quot;conversationId&quot;, notification.conversationId)&#10;            putExtra(&quot;title&quot;, notification.title)&#10;            putExtra(&quot;text&quot;, notification.text)&#10;            putExtra(&quot;sender&quot;, notification.sender)&#10;            putExtra(&quot;packageName&quot;, notification.packageName)&#10;            putExtra(&quot;timestamp&quot;, notification.time)&#10;        }&#10;&#10;        LocalBroadcastManager.getInstance(this).sendBroadcast(intent)&#10;    }&#10;&#10;    /**&#10;     * Send smart reply using RemoteInput&#10;     */&#10;    fun sendSmartReply(sbn: StatusBarNotification, replyText: String): Boolean {&#10;        try {&#10;            val notification = sbn.notification&#10;            val actions = notification.actions ?: return false&#10;&#10;            // Find reply action&#10;            var replyAction: Notification.Action? = null&#10;            var remoteInput: RemoteInput? = null&#10;&#10;            for (action in actions) {&#10;                val remoteInputs = action.remoteInputs&#10;                if (remoteInputs != null &amp;&amp; remoteInputs.isNotEmpty()) {&#10;                    replyAction = action&#10;                    remoteInput = remoteInputs[0]&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (replyAction == null || remoteInput == null) {&#10;                Log.e(TAG, &quot;No reply action found for notification&quot;)&#10;                return false&#10;            }&#10;&#10;            // Create reply intent&#10;            val replyIntent = Intent()&#10;            val bundle = Bundle()&#10;            bundle.putCharSequence(remoteInput.resultKey, replyText)&#10;            RemoteInput.addResultsToIntent(arrayOf(remoteInput), replyIntent, bundle)&#10;&#10;            // Send reply&#10;            replyAction.actionIntent.send(this, 0, replyIntent)&#10;&#10;            Log.d(TAG, &quot;Smart reply sent: $replyText&quot;)&#10;            return true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending smart reply: ${e.message}&quot;, e)&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send smart reply by conversation ID&#10;     */&#10;    fun sendSmartReplyByConversationId(conversationId: String, replyText: String): Boolean {&#10;        val notifications = NotificationMemoryStore.getNotificationsByConversation(conversationId)&#10;        val latestNotificationWithReply = notifications.firstOrNull { it.hasReplyAction }&#10;&#10;        if (latestNotificationWithReply?.replyAction != null &amp;&amp; latestNotificationWithReply.remoteInput != null) {&#10;            try {&#10;                val replyIntent = Intent()&#10;                val bundle = Bundle()&#10;                bundle.putCharSequence(latestNotificationWithReply.remoteInput.resultKey, replyText)&#10;                RemoteInput.addResultsToIntent(arrayOf(latestNotificationWithReply.remoteInput), replyIntent, bundle)&#10;&#10;                latestNotificationWithReply.replyAction.actionIntent.send(this, 0, replyIntent)&#10;&#10;                Log.d(TAG, &quot;Smart reply sent via conversation ID: $replyText&quot;)&#10;                return true&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error sending smart reply via conversation ID: ${e.message}&quot;, e)&#10;                return false&#10;            }&#10;        }&#10;&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Handle AI-generated reply and attempt to send it&#10;     */&#10;    private fun handleGeneratedReply(intent: Intent) {&#10;        val conversationId = intent.getStringExtra(&quot;conversationId&quot;) ?: return&#10;        val replyText = intent.getStringExtra(&quot;replyText&quot;) ?: return&#10;        val packageName = intent.getStringExtra(&quot;packageName&quot;) ?: return&#10;        val notificationHash = intent.getStringExtra(&quot;notificationHash&quot;) ?: return&#10;&#10;        Log.d(TAG, &quot; Received AI-generated reply for conversation: $conversationId&quot;)&#10;        Log.d(TAG, &quot; Reply: ${replyText.take(100)}...&quot;)&#10;&#10;        // Attempt to send the reply&#10;        val success = sendSmartReplyByConversationId(conversationId, replyText)&#10;&#10;        // Update notification status&#10;        if (success) {&#10;            NotificationMemoryStore.markAsSent(notificationHash)&#10;            Log.d(TAG, &quot;✅ Reply sent successfully&quot;)&#10;        } else {&#10;            Log.e(TAG, &quot;❌ Failed to send reply&quot;)&#10;        }&#10;&#10;        // Broadcast reply sent status&#10;        val statusIntent = Intent(REPLY_SENT_ACTION).apply {&#10;            putExtra(&quot;conversationId&quot;, conversationId)&#10;            putExtra(&quot;notificationHash&quot;, notificationHash)&#10;            putExtra(&quot;success&quot;, success)&#10;            putExtra(&quot;replyText&quot;, replyText)&#10;        }&#10;        localBroadcastManager.sendBroadcast(statusIntent)&#10;    }&#10;&#10;    override fun onNotificationRemoved(sbn: StatusBarNotification) {&#10;        val packageName = sbn.packageName ?: return&#10;        if (isSupportedApp(packageName)) {&#10;            Log.d(TAG, &quot;Notification removed from ${SUPPORTED_APPS[packageName]}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.jawafai.service&#10;&#10;import android.service.notification.NotificationListenerService&#10;import android.service.notification.StatusBarNotification&#10;import android.content.Intent&#10;import android.content.BroadcastReceiver&#10;import android.content.IntentFilter&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager&#10;import android.content.Context&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.app.RemoteInput&#10;import android.app.Notification&#10;import android.app.PendingIntent&#10;import android.os.Bundle&#10;import kotlin.random.Random&#10;&#10;class JawafaiNotificationListenerService : NotificationListenerService() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;JawafaiNotifService&quot;&#10;        const val NOTIFICATION_BROADCAST_ACTION = &quot;com.example.jawafai.NOTIFICATION_LISTENER_EVENT&quot;&#10;        const val AI_REPLY_BROADCAST_ACTION = &quot;com.example.jawafai.AI_REPLY_REQUEST&quot;&#10;        const val REPLY_GENERATED_ACTION = &quot;com.example.jawafai.REPLY_GENERATED&quot;&#10;        const val REPLY_SENT_ACTION = &quot;com.example.jawafai.REPLY_SENT&quot;&#10;&#10;        // Define the package names of apps we want to capture notifications from&#10;        private val SUPPORTED_APPS = mapOf(&#10;            &quot;com.instagram.android&quot; to &quot;Instagram&quot;,&#10;            &quot;com.whatsapp&quot; to &quot;WhatsApp&quot;,&#10;            &quot;com.facebook.orca&quot; to &quot;Facebook Messenger&quot;,&#10;            &quot;com.whatsapp.w4b&quot; to &quot;WhatsApp Business&quot;,&#10;            &quot;com.facebook.katana&quot; to &quot;Facebook&quot;,&#10;            &quot;com.snapchat.android&quot; to &quot;Snapchat&quot;,&#10;            &quot;com.twitter.android&quot; to &quot;Twitter&quot;,&#10;            &quot;com.telegram.messenger&quot; to &quot;Telegram&quot;&#10;        )&#10;&#10;        // Utility to check if notification access is enabled&#10;        fun isNotificationAccessEnabled(context: Context): Boolean {&#10;            val enabledListeners = Settings.Secure.getString(&#10;                context.contentResolver,&#10;                &quot;enabled_notification_listeners&quot;&#10;            ) ?: return false&#10;            return enabledListeners.contains(context.packageName)&#10;        }&#10;    }&#10;&#10;    private val localBroadcastManager by lazy { LocalBroadcastManager.getInstance(this) }&#10;&#10;    // Broadcast receiver for handling AI-generated replies&#10;    private val replyReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                REPLY_GENERATED_ACTION -&gt; handleGeneratedReply(intent)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onListenerConnected() {&#10;        super.onListenerConnected()&#10;        Log.d(TAG, &quot;Smart Messaging Assistant connected!&quot;)&#10;&#10;        // Register broadcast receiver for AI replies&#10;        val filter = IntentFilter(REPLY_GENERATED_ACTION)&#10;        localBroadcastManager.registerReceiver(replyReceiver, filter)&#10;    }&#10;&#10;    override fun onListenerDisconnected() {&#10;        super.onListenerDisconnected()&#10;        Log.d(TAG, &quot;Smart Messaging Assistant disconnected!&quot;)&#10;&#10;        // Unregister broadcast receiver&#10;        try {&#10;            localBroadcastManager.unregisterReceiver(replyReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error unregistering receiver: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun isSupportedApp(packageName: String): Boolean {&#10;        return SUPPORTED_APPS.containsKey(packageName)&#10;    }&#10;&#10;    override fun onNotificationPosted(sbn: StatusBarNotification) {&#10;        val packageName = sbn.packageName ?: return&#10;&#10;        // Skip our own notifications and unsupported apps&#10;        if (packageName == this.packageName || !isSupportedApp(packageName)) {&#10;            Log.d(TAG, &quot;Notification ignored - not from supported app: $packageName&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(TAG, &quot;Processing notification from ${SUPPORTED_APPS[packageName]}&quot;)&#10;&#10;        try {&#10;            val smartNotification = extractNotificationData(sbn)&#10;&#10;            // Store notification with deduplication&#10;            val isNewNotification = NotificationMemoryStore.addNotification(smartNotification)&#10;&#10;            if (isNewNotification) {&#10;                Log.d(TAG, &quot;New notification stored: ${smartNotification.conversationId}&quot;)&#10;&#10;                // Broadcast to AI module if reply action is available&#10;                if (smartNotification.hasReplyAction) {&#10;                    triggerAIReplyGeneration(smartNotification)&#10;                }&#10;            } else {&#10;                Log.d(TAG, &quot;Duplicate notification ignored&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error processing notification: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract comprehensive notification data for smart messaging&#10;     */&#10;    private fun extractNotificationData(sbn: StatusBarNotification): NotificationMemoryStore.ExternalNotification {&#10;        val notification = sbn.notification&#10;        val extras = notification.extras&#10;        val packageName = sbn.packageName&#10;&#10;        // Extract basic notification fields&#10;        val title = extras.getString(Notification.EXTRA_TITLE) ?: &quot;(No Title)&quot;&#10;        val text = extras.getCharSequence(Notification.EXTRA_TEXT)?.toString() ?: &quot;(No Text)&quot;&#10;        val sender = extras.getString(Notification.EXTRA_SUB_TEXT)&#10;        val conversationTitle = extras.getString(Notification.EXTRA_CONVERSATION_TITLE)&#10;        val timestamp = sbn.postTime&#10;&#10;        // Generate conversation ID - use notification key or create custom one&#10;        val conversationId = generateConversationId(sbn, title, sender)&#10;&#10;        // Check for reply action and RemoteInput&#10;        val (hasReplyAction, replyAction, remoteInput) = extractReplyAction(notification)&#10;&#10;        // Generate hash for deduplication&#10;        val hash = NotificationMemoryStore.generateHash(title, text, packageName)&#10;        &#10;        // Capture ALL raw extras for debugging/analysis&#10;        val rawExtras = mutableMapOf&lt;String, String&gt;()&#10;        extras.keySet()?.forEach { key -&gt;&#10;            val value = extras.get(key)&#10;            rawExtras[key] = when (value) {&#10;                is CharSequence -&gt; value.toString()&#10;                is Array&lt;*&gt; -&gt; value.joinToString(&quot;, &quot;) { it.toString() }&#10;                else -&gt; value.toString()&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Extracted notification data:&quot;)&#10;        Log.d(TAG, &quot;  Title: $title&quot;)&#10;        Log.d(TAG, &quot;  Text: $text&quot;)&#10;        Log.d(TAG, &quot;  Sender: $sender&quot;)&#10;        Log.d(TAG, &quot;  ConversationId: $conversationId&quot;)&#10;        Log.d(TAG, &quot;  HasReplyAction: $hasReplyAction&quot;)&#10;        Log.d(TAG, &quot;  Raw Extras Count: ${rawExtras.size}&quot;)&#10;&#10;        return NotificationMemoryStore.ExternalNotification(&#10;            title = title,&#10;            text = text,&#10;            packageName = packageName,&#10;            time = timestamp,&#10;            sender = sender,&#10;            conversationTitle = conversationTitle,&#10;            conversationId = conversationId,&#10;            hasReplyAction = hasReplyAction,&#10;            replyAction = replyAction,&#10;            remoteInput = remoteInput,&#10;            hash = hash,&#10;            rawExtras = rawExtras&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Generate unique conversation ID&#10;     */&#10;    private fun generateConversationId(sbn: StatusBarNotification, title: String, sender: String?): String {&#10;        // Try to use notification key first&#10;        val notificationKey = sbn.key&#10;        if (notificationKey.isNotBlank()) {&#10;            return &quot;${sbn.packageName}_${notificationKey.hashCode()}&quot;&#10;        }&#10;&#10;        // Fallback to combination of package, title, and sender&#10;        val identifier = &quot;${sbn.packageName}_${title}_${sender ?: &quot;unknown&quot;}&quot;&#10;        return identifier.hashCode().toString()&#10;    }&#10;&#10;    /**&#10;     * Extract reply action and RemoteInput from notification&#10;     */&#10;    private fun extractReplyAction(notification: Notification): Triple&lt;Boolean, Notification.Action?, RemoteInput?&gt; {&#10;        val actions = notification.actions ?: return Triple(false, null, null)&#10;&#10;        for (action in actions) {&#10;            val remoteInputs = action.remoteInputs&#10;            if (remoteInputs != null &amp;&amp; remoteInputs.isNotEmpty()) {&#10;                // Found reply action with RemoteInput&#10;                Log.d(TAG, &quot;Reply action found: ${action.title}&quot;)&#10;                return Triple(true, action, remoteInputs[0])&#10;            }&#10;        }&#10;&#10;        return Triple(false, null, null)&#10;    }&#10;&#10;    /**&#10;     * Trigger AI reply generation via broadcast&#10;     */&#10;    private fun triggerAIReplyGeneration(notification: NotificationMemoryStore.ExternalNotification) {&#10;        Log.d(TAG, &quot;Triggering AI reply generation for: ${notification.conversationId}&quot;)&#10;&#10;        val intent = Intent(AI_REPLY_BROADCAST_ACTION).apply {&#10;            putExtra(&quot;conversationId&quot;, notification.conversationId)&#10;            putExtra(&quot;title&quot;, notification.title)&#10;            putExtra(&quot;text&quot;, notification.text)&#10;            putExtra(&quot;sender&quot;, notification.sender)&#10;            putExtra(&quot;packageName&quot;, notification.packageName)&#10;            putExtra(&quot;timestamp&quot;, notification.time)&#10;        }&#10;&#10;        LocalBroadcastManager.getInstance(this).sendBroadcast(intent)&#10;    }&#10;&#10;    /**&#10;     * Send smart reply using RemoteInput&#10;     */&#10;    fun sendSmartReply(sbn: StatusBarNotification, replyText: String): Boolean {&#10;        try {&#10;            val notification = sbn.notification&#10;            val actions = notification.actions ?: return false&#10;&#10;            // Find reply action&#10;            var replyAction: Notification.Action? = null&#10;            var remoteInput: RemoteInput? = null&#10;&#10;            for (action in actions) {&#10;                val remoteInputs = action.remoteInputs&#10;                if (remoteInputs != null &amp;&amp; remoteInputs.isNotEmpty()) {&#10;                    replyAction = action&#10;                    remoteInput = remoteInputs[0]&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (replyAction == null || remoteInput == null) {&#10;                Log.e(TAG, &quot;No reply action found for notification&quot;)&#10;                return false&#10;            }&#10;&#10;            // Create reply intent&#10;            val replyIntent = Intent()&#10;            val bundle = Bundle()&#10;            bundle.putCharSequence(remoteInput.resultKey, replyText)&#10;            RemoteInput.addResultsToIntent(arrayOf(remoteInput), replyIntent, bundle)&#10;&#10;            // Send reply&#10;            replyAction.actionIntent.send(this, 0, replyIntent)&#10;&#10;            Log.d(TAG, &quot;Smart reply sent: $replyText&quot;)&#10;            return true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending smart reply: ${e.message}&quot;, e)&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send smart reply by conversation ID&#10;     */&#10;    fun sendSmartReplyByConversationId(conversationId: String, replyText: String): Boolean {&#10;        val notifications = NotificationMemoryStore.getNotificationsByConversation(conversationId)&#10;        val latestNotificationWithReply = notifications.firstOrNull { it.hasReplyAction }&#10;&#10;        if (latestNotificationWithReply?.replyAction != null &amp;&amp; latestNotificationWithReply.remoteInput != null) {&#10;            try {&#10;                val replyIntent = Intent()&#10;                val bundle = Bundle()&#10;                bundle.putCharSequence(latestNotificationWithReply.remoteInput.resultKey, replyText)&#10;                RemoteInput.addResultsToIntent(arrayOf(latestNotificationWithReply.remoteInput), replyIntent, bundle)&#10;&#10;                latestNotificationWithReply.replyAction.actionIntent.send(this, 0, replyIntent)&#10;&#10;                Log.d(TAG, &quot;Smart reply sent via conversation ID: $replyText&quot;)&#10;                return true&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error sending smart reply via conversation ID: ${e.message}&quot;, e)&#10;                return false&#10;            }&#10;        }&#10;&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Handle AI-generated reply and attempt to send it&#10;     */&#10;    private fun handleGeneratedReply(intent: Intent) {&#10;        val conversationId = intent.getStringExtra(&quot;conversationId&quot;) ?: return&#10;        val replyText = intent.getStringExtra(&quot;replyText&quot;) ?: return&#10;        val packageName = intent.getStringExtra(&quot;packageName&quot;) ?: return&#10;        val notificationHash = intent.getStringExtra(&quot;notificationHash&quot;) ?: return&#10;&#10;        Log.d(TAG, &quot; Received AI-generated reply for conversation: $conversationId&quot;)&#10;        Log.d(TAG, &quot; Reply: ${replyText.take(100)}...&quot;)&#10;&#10;        // Attempt to send the reply&#10;        val success = sendSmartReplyByConversationId(conversationId, replyText)&#10;&#10;        // Update notification status&#10;        if (success) {&#10;            NotificationMemoryStore.markAsSent(notificationHash)&#10;            Log.d(TAG, &quot;✅ Reply sent successfully&quot;)&#10;        } else {&#10;            Log.e(TAG, &quot;❌ Failed to send reply&quot;)&#10;        }&#10;&#10;        // Broadcast reply sent status&#10;        val statusIntent = Intent(REPLY_SENT_ACTION).apply {&#10;            putExtra(&quot;conversationId&quot;, conversationId)&#10;            putExtra(&quot;notificationHash&quot;, notificationHash)&#10;            putExtra(&quot;success&quot;, success)&#10;            putExtra(&quot;replyText&quot;, replyText)&#10;        }&#10;        localBroadcastManager.sendBroadcast(statusIntent)&#10;    }&#10;&#10;    override fun onNotificationRemoved(sbn: StatusBarNotification) {&#10;        val packageName = sbn.packageName ?: return&#10;        if (isSupportedApp(packageName)) {&#10;            Log.d(TAG, &quot;Notification removed from ${SUPPORTED_APPS[packageName]}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/service/NotificationMemoryStore.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/service/NotificationMemoryStore.kt" />
              <option name="originalContent" value="package com.example.jawafai.service&#10;&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.snapshots.SnapshotStateList&#10;import android.app.RemoteInput&#10;import android.app.Notification&#10;import java.security.MessageDigest&#10;&#10;// Enhanced in-memory notification store for smart messaging assistant&#10;object NotificationMemoryStore {&#10;    data class ExternalNotification(&#10;        val title: String,                    // Group name or sender&#10;        val text: String,                     // Message content&#10;        val packageName: String,              // App package name&#10;        val time: Long,                       // Timestamp&#10;        val sender: String? = null,           // android.subText - actual sender&#10;        val conversationTitle: String? = null, // For group chats&#10;        val conversationId: String,           // Unique conversation identifier&#10;        val hasReplyAction: Boolean = false,  // Whether reply action is available&#10;        val replyAction: Notification.Action? = null, // Reply action reference&#10;        val remoteInput: RemoteInput? = null, // RemoteInput reference&#10;        val hash: String,                     // For deduplication&#10;        val ai_reply: String = &quot;&quot;,            // AI generated reply (empty if not generated)&#10;        val is_sent: Boolean = false          // Whether reply was sent via RemoteInput&#10;    )&#10;&#10;    private val notifications: SnapshotStateList&lt;ExternalNotification&gt; = mutableStateListOf()&#10;    private val notificationHashes: MutableSet&lt;String&gt; = mutableSetOf()&#10;&#10;    /**&#10;     * Add notification with deduplication&#10;     */&#10;    fun addNotification(notification: ExternalNotification): Boolean {&#10;        return if (!notificationHashes.contains(notification.hash)) {&#10;            notifications.add(0, notification) // Add to top&#10;            notificationHashes.add(notification.hash)&#10;&#10;            // Limit store size to prevent memory issues&#10;            if (notifications.size &gt; 500) {&#10;                val removed = notifications.removeAt(notifications.size - 1)&#10;                notificationHashes.remove(removed.hash)&#10;            }&#10;            true&#10;        } else {&#10;            false // Duplicate notification&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all notifications&#10;     */&#10;    fun getAllNotifications(): List&lt;ExternalNotification&gt; = notifications.toList()&#10;&#10;    /**&#10;     * Get notifications by package name&#10;     */&#10;    fun getNotificationsByPackage(packageName: String): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.packageName == packageName }&#10;    }&#10;&#10;    /**&#10;     * Get notifications by conversation ID&#10;     */&#10;    fun getNotificationsByConversation(conversationId: String): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.conversationId == conversationId }&#10;    }&#10;&#10;    /**&#10;     * Get notifications with reply actions&#10;     */&#10;    fun getNotificationsWithReplyActions(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.hasReplyAction }&#10;    }&#10;&#10;    /**&#10;     * Clear all notifications&#10;     */&#10;    fun clear() {&#10;        notifications.clear()&#10;        notificationHashes.clear()&#10;    }&#10;&#10;    /**&#10;     * Generate hash for deduplication&#10;     */&#10;    fun generateHash(title: String, text: String, packageName: String): String {&#10;        val input = &quot;$title|$text|$packageName&quot;&#10;        val digest = MessageDigest.getInstance(&quot;MD5&quot;)&#10;        val hashBytes = digest.digest(input.toByteArray())&#10;        return hashBytes.joinToString(&quot;&quot;) { &quot;%02x&quot;.format(it) }&#10;    }&#10;&#10;    /**&#10;     * Get conversation context for AI processing&#10;     */&#10;    fun getConversationContext(conversationId: String, limit: Int = 10): List&lt;ExternalNotification&gt; {&#10;        return notifications&#10;            .filter { it.conversationId == conversationId }&#10;            .take(limit)&#10;            .reversed() // Chronological order for context&#10;    }&#10;&#10;    /**&#10;     * Update AI reply for a notification&#10;     */&#10;    fun updateAIReply(hash: String, aiReply: String): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(ai_reply = aiReply)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Mark notification as sent&#10;     */&#10;    fun markAsSent(hash: String): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(is_sent = true)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Update both AI reply and sent status&#10;     */&#10;    fun updateReplyAndSentStatus(hash: String, aiReply: String, isSent: Boolean): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(ai_reply = aiReply, is_sent = isSent)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Get notifications with AI replies&#10;     */&#10;    fun getNotificationsWithAIReplies(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.ai_reply.isNotBlank() }&#10;    }&#10;&#10;    /**&#10;     * Get unsent notifications with AI replies&#10;     */&#10;    fun getUnsentAIReplies(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.ai_reply.isNotBlank() &amp;&amp; !it.is_sent }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.jawafai.service&#10;&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.snapshots.SnapshotStateList&#10;import android.app.RemoteInput&#10;import android.app.Notification&#10;import android.util.Log&#10;import java.security.MessageDigest&#10;&#10;// Enhanced in-memory notification store for smart messaging assistant&#10;object NotificationMemoryStore {&#10;&#10;    // Table 1: Conversations (Inbox view)&#10;    // Note: display_name should always be the OTHER person's name (not &quot;You&quot; or current user)&#10;    // This matches how WhatsApp/Messenger show conversations&#10;    data class Conversation(&#10;        val convo_id: String,              // e.g., &quot;com.whatsapp_170762839&quot;&#10;        val package_name: String,          // e.g., &quot;com.whatsapp&quot;&#10;        val display_name: String,          // OTHER person's name (e.g., &quot;Biplov Gautam&quot;)&#10;        val last_msg_time: Long,           // Timestamp for sorting&#10;        val last_msg_content: String,      // Last message preview&#10;        val platform_id: String? = null,   // Optional platform-specific ID&#10;        val unread_count: Int = 0          // Number of unread messages&#10;    )&#10;&#10;    // Table 2: Messages (Chat history)&#10;    // Note: sender_name identifies WHO sent each specific message&#10;    // This allows distinguishing between messages from different people in a conversation&#10;    data class Message(&#10;        val msg_id: String,                // Using hash as unique ID&#10;        val convo_id: String,              // Foreign key to Conversation&#10;        val sender_name: String,           // WHO sent this specific message (could be different people)&#10;        val msg_content: String,           // The text&#10;        val timestamp: Long,               // When it was sent&#10;        val is_outgoing: Boolean = false,  // True if from current user (all notifications are incoming)&#10;        val msg_hash: String,              // Deduplication&#10;        val has_reply_action: Boolean = false,&#10;        val ai_reply: String = &quot;&quot;,&#10;        val is_sent: Boolean = false&#10;    )&#10;&#10;    // Original notification data (kept for compatibility)&#10;    data class ExternalNotification(&#10;        val title: String,                    // Group name or sender&#10;        val text: String,                     // Message content&#10;        val packageName: String,              // App package name&#10;        val time: Long,                       // Timestamp&#10;        val sender: String? = null,           // android.subText - actual sender&#10;        val conversationTitle: String? = null, // For group chats&#10;        val conversationId: String,           // Unique conversation identifier&#10;        val hasReplyAction: Boolean = false,  // Whether reply action is available&#10;        val replyAction: Notification.Action? = null, // Reply action reference&#10;        val remoteInput: RemoteInput? = null, // RemoteInput reference&#10;        val hash: String,                     // For deduplication&#10;        val ai_reply: String = &quot;&quot;,            // AI generated reply (empty if not generated)&#10;        val is_sent: Boolean = false,         // Whether reply was sent via RemoteInput&#10;        val rawExtras: Map&lt;String, String&gt; = emptyMap() // ALL raw notification extras for debugging&#10;    )&#10;&#10;    private val notifications: SnapshotStateList&lt;ExternalNotification&gt; = mutableStateListOf()&#10;    private val notificationHashes: MutableSet&lt;String&gt; = mutableSetOf()&#10;&#10;    // Conversation-based storage&#10;    private val conversations: SnapshotStateList&lt;Conversation&gt; = mutableStateListOf()&#10;    private val messages: SnapshotStateList&lt;Message&gt; = mutableStateListOf()&#10;&#10;    /**&#10;     * Check if notification is a WhatsApp summary notification (not actual message)&#10;     * Examples: &quot;2 new messages&quot;, &quot;4 messages&quot;, &quot;3 new messages from...&quot;, &quot;2 messages from 2 chats&quot;&#10;     */&#10;    private fun isSummaryNotification(text: String): Boolean {&#10;        val lowerText = text.lowercase().trim()&#10;&#10;        // Pattern 1: &quot;X new messages&quot; or &quot;X messages&quot;&#10;        val summaryPattern1 = Regex(&quot;^\\d+\\s+(new\\s+)?messages?$&quot;)&#10;        if (summaryPattern1.matches(lowerText)) return true&#10;&#10;        // Pattern 2: &quot;X new messages from...&quot; (group chat summary)&#10;        val summaryPattern2 = Regex(&quot;^\\d+\\s+new\\s+messages?\\s+from.*&quot;)&#10;        if (summaryPattern2.matches(lowerText)) return true&#10;&#10;        // Pattern 3: Single digit followed by &quot;messages&quot; (e.g., &quot;2 messages&quot;)&#10;        if (lowerText.matches(Regex(&quot;^\\d{1,3}\\s+messages?$&quot;))) return true&#10;&#10;        // Pattern 4: &quot;X messages from X chats&quot; (WhatsApp multiple chat summary)&#10;        val summaryPattern4 = Regex(&quot;^\\d+\\s+messages?\\s+from\\s+\\d+\\s+chats?$&quot;)&#10;        if (summaryPattern4.matches(lowerText)) return true&#10;&#10;        // Pattern 5: &quot;X new messages from X chats&quot;&#10;        val summaryPattern5 = Regex(&quot;^\\d+\\s+new\\s+messages?\\s+from\\s+\\d+\\s+chats?$&quot;)&#10;        if (summaryPattern5.matches(lowerText)) return true&#10;&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Add notification with deduplication&#10;     * Also updates Conversations and Messages tables&#10;     * Filters out WhatsApp summary notifications&#10;     */&#10;    fun addNotification(notification: ExternalNotification): Boolean {&#10;        // Skip WhatsApp summary notifications (e.g., &quot;2 new messages&quot;)&#10;        if (isSummaryNotification(notification.text)) {&#10;            Log.d(&quot;NotificationMemoryStore&quot;, &quot;Skipping summary notification: ${notification.text}&quot;)&#10;            return false&#10;        }&#10;&#10;        return if (!notificationHashes.contains(notification.hash)) {&#10;            notifications.add(0, notification) // Add to top&#10;            notificationHashes.add(notification.hash)&#10;&#10;            // Add to conversation-based storage&#10;            addToConversationStore(notification)&#10;&#10;            // Limit store size to prevent memory issues&#10;            if (notifications.size &gt; 500) {&#10;                val removed = notifications.removeAt(notifications.size - 1)&#10;                notificationHashes.remove(removed.hash)&#10;            }&#10;            true&#10;        } else {&#10;            false // Duplicate notification&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Add notification to conversation-based storage (Table 1 &amp; 2)&#10;     */&#10;    private fun addToConversationStore(notification: ExternalNotification) {&#10;        val convo_id = notification.conversationId&#10;        val package_name = notification.packageName&#10;        val msg_content = notification.text&#10;        val timestamp = notification.time&#10;&#10;        // Determine if this is an outgoing message&#10;        // In WhatsApp: title = &quot;You&quot; means YOU sent the message (outgoing)&#10;        val title = notification.title&#10;        val sender = notification.sender&#10;        val is_outgoing = title.equals(&quot;You&quot;, ignoreCase = true)&#10;&#10;        // Determine sender name and display name&#10;        val sender_name: String&#10;        val should_update_display_name: Boolean&#10;&#10;        if (is_outgoing) {&#10;            // Outgoing message (You sent it)&#10;            // sender_name = &quot;You&quot; (for message bubble)&#10;            // DON'T update conversation display_name (keep showing the recipient's name)&#10;            sender_name = &quot;You&quot;&#10;            should_update_display_name = false&#10;        } else {&#10;            // Incoming message (Someone sent it to you)&#10;            // sender_name = actual sender&#10;            // DO update conversation display_name to show who sent it&#10;            sender_name = sender ?: title&#10;            should_update_display_name = true&#10;        }&#10;&#10;        // Update or create conversation (Table 1)&#10;        val existingConvoIndex = conversations.indexOfFirst { it.convo_id == convo_id }&#10;        if (existingConvoIndex != -1) {&#10;            // Update existing conversation&#10;            val existingConvo = conversations[existingConvoIndex]&#10;            conversations.removeAt(existingConvoIndex)&#10;            conversations.add(0, existingConvo.copy(&#10;                last_msg_time = timestamp,&#10;                last_msg_content = msg_content,&#10;                unread_count = if (is_outgoing) existingConvo.unread_count else existingConvo.unread_count + 1,&#10;                // Only update display_name if it's NOT an outgoing message&#10;                display_name = if (should_update_display_name) sender_name else existingConvo.display_name&#10;            ))&#10;        } else {&#10;            // Create new conversation&#10;            // For first message, use sender_name as display_name&#10;            // (If it's &quot;You&quot;, we'll update it when we receive the first incoming message)&#10;            conversations.add(0, Conversation(&#10;                convo_id = convo_id,&#10;                package_name = package_name,&#10;                display_name = if (should_update_display_name) sender_name else &quot;Unknown&quot;, // Will be updated on first incoming message&#10;                last_msg_time = timestamp,&#10;                last_msg_content = msg_content,&#10;                platform_id = null,&#10;                unread_count = if (is_outgoing) 0 else 1&#10;            ))&#10;        }&#10;&#10;        // Add message (Table 2)&#10;        val message = Message(&#10;            msg_id = notification.hash,&#10;            convo_id = convo_id,&#10;            sender_name = sender_name, // &quot;You&quot; if outgoing, actual sender if incoming&#10;            msg_content = msg_content,&#10;            timestamp = timestamp,&#10;            is_outgoing = is_outgoing,&#10;            msg_hash = notification.hash,&#10;            has_reply_action = notification.hasReplyAction,&#10;            ai_reply = notification.ai_reply,&#10;            is_sent = notification.is_sent&#10;        )&#10;        messages.add(0, message)&#10;&#10;        // Limit messages per conversation&#10;        val convoMessages = messages.filter { it.convo_id == convo_id }&#10;        if (convoMessages.size &gt; 100) {&#10;            val oldestMessage = convoMessages.last()&#10;            messages.remove(oldestMessage)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all conversations sorted by last message time&#10;     */&#10;    fun getAllConversations(): List&lt;Conversation&gt; {&#10;        return conversations.sortedByDescending { it.last_msg_time }&#10;    }&#10;&#10;    /**&#10;     * Get messages for a specific conversation&#10;     */&#10;    fun getMessagesForConversation(convo_id: String): List&lt;Message&gt; {&#10;        return messages.filter { it.convo_id == convo_id }.sortedBy { it.timestamp }&#10;    }&#10;&#10;    /**&#10;     * Mark conversation as read&#10;     */&#10;    fun markConversationAsRead(convo_id: String) {&#10;        val index = conversations.indexOfFirst { it.convo_id == convo_id }&#10;        if (index != -1) {&#10;            conversations[index] = conversations[index].copy(unread_count = 0)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update AI reply for a message&#10;     */&#10;    fun updateMessageAIReply(msg_hash: String, aiReply: String): Boolean {&#10;        val msgIndex = messages.indexOfFirst { it.msg_hash == msg_hash }&#10;        if (msgIndex != -1) {&#10;            messages[msgIndex] = messages[msgIndex].copy(ai_reply = aiReply)&#10;&#10;            // Also update in notifications list&#10;            updateAIReply(msg_hash, aiReply)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Mark message as sent&#10;     */&#10;    fun markMessageAsSent(msg_hash: String): Boolean {&#10;        val msgIndex = messages.indexOfFirst { it.msg_hash == msg_hash }&#10;        if (msgIndex != -1) {&#10;            messages[msgIndex] = messages[msgIndex].copy(is_sent = true)&#10;&#10;            // Also update in notifications list&#10;            markAsSent(msg_hash)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Get all notifications&#10;     */&#10;    fun getAllNotifications(): List&lt;ExternalNotification&gt; = notifications.toList()&#10;&#10;    /**&#10;     * Get notifications by package name&#10;     */&#10;    fun getNotificationsByPackage(packageName: String): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.packageName == packageName }&#10;    }&#10;&#10;    /**&#10;     * Get notifications by conversation ID&#10;     */&#10;    fun getNotificationsByConversation(conversationId: String): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.conversationId == conversationId }&#10;    }&#10;&#10;    /**&#10;     * Get notifications with reply actions&#10;     */&#10;    fun getNotificationsWithReplyActions(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.hasReplyAction }&#10;    }&#10;&#10;    /**&#10;     * Clear all notifications, conversations, and messages&#10;     */&#10;    fun clear() {&#10;        notifications.clear()&#10;        notificationHashes.clear()&#10;        conversations.clear()&#10;        messages.clear()&#10;    }&#10;&#10;    /**&#10;     * Generate hash for deduplication&#10;     */&#10;    fun generateHash(title: String, text: String, packageName: String): String {&#10;        val input = &quot;$title|$text|$packageName&quot;&#10;        val digest = MessageDigest.getInstance(&quot;MD5&quot;)&#10;        val hashBytes = digest.digest(input.toByteArray())&#10;        return hashBytes.joinToString(&quot;&quot;) { &quot;%02x&quot;.format(it) }&#10;    }&#10;&#10;    /**&#10;     * Get conversation context for AI processing&#10;     */&#10;    fun getConversationContext(conversationId: String, limit: Int = 10): List&lt;ExternalNotification&gt; {&#10;        return notifications&#10;            .filter { it.conversationId == conversationId }&#10;            .take(limit)&#10;            .reversed() // Chronological order for context&#10;    }&#10;&#10;    /**&#10;     * Update AI reply for a notification&#10;     */&#10;    fun updateAIReply(hash: String, aiReply: String): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(ai_reply = aiReply)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Mark notification as sent&#10;     */&#10;    fun markAsSent(hash: String): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(is_sent = true)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Update both AI reply and sent status&#10;     */&#10;    fun updateReplyAndSentStatus(hash: String, aiReply: String, isSent: Boolean): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(ai_reply = aiReply, is_sent = isSent)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Get notifications with AI replies&#10;     */&#10;    fun getNotificationsWithAIReplies(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.ai_reply.isNotBlank() }&#10;    }&#10;&#10;    /**&#10;     * Get unsent notifications with AI replies&#10;     */&#10;    fun getUnsentAIReplies(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.ai_reply.isNotBlank() &amp;&amp; !it.is_sent }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/view/dashboard/notifications/NotificationScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/view/dashboard/notifications/NotificationScreen.kt" />
              <option name="originalContent" value="package com.example.jawafai.view.dashboard.notifications&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.OnBackPressedCallback&#10;import androidx.activity.compose.LocalOnBackPressedDispatcherOwner&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager&#10;import coil.compose.AsyncImage&#10;import com.example.jawafai.R&#10;import com.example.jawafai.managers.GroqApiManager&#10;import com.example.jawafai.service.NotificationMemoryStore&#10;import com.example.jawafai.service.NotificationAIReplyManager&#10;import com.example.jawafai.service.SmartReplyAIModule&#10;import com.example.jawafai.service.RemoteReplyService&#10;import com.example.jawafai.ui.theme.AppFonts&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;// Data classes for chat notifications&#10;data class ChatNotification(&#10;    val id: String,&#10;    val platform: ChatPlatform,&#10;    val senderName: String,&#10;    val senderAvatar: String?,&#10;    val message: String,&#10;    val timestamp: Long,&#10;    val isRead: Boolean,&#10;    val hasGeneratedReply: Boolean = false,&#10;    val generatedReply: String = &quot;&quot;,&#10;    val hasReplyAction: Boolean = false,&#10;    val isSent: Boolean = false,&#10;    val conversationId: String = &quot;&quot;,&#10;    val notificationHash: String = &quot;&quot;&#10;)&#10;&#10;enum class ChatPlatform(&#10;    val displayName: String,&#10;    val color: Color,&#10;    val iconRes: Int? = null&#10;) {&#10;    WHATSAPP(&quot;WhatsApp&quot;, Color(0xFF25D366)),&#10;    INSTAGRAM(&quot;Instagram&quot;, Color(0xFFE4405F)),&#10;    MESSENGER(&quot;Messenger&quot;, Color(0xFF0084FF)),&#10;    GENERAL(&quot;General&quot;, Color(0xFF395B64))&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun NotificationScreen(&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val backDispatcher = LocalOnBackPressedDispatcherOwner.current?.onBackPressedDispatcher&#10;&#10;    // State management&#10;    var isRefreshing by remember { mutableStateOf(false) }&#10;    var selectedFilter by remember { mutableStateOf&lt;ChatPlatform?&gt;(null) }&#10;    var generatingReplyFor by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Send status tracking&#10;    var sendingStatus by remember { mutableStateOf&lt;Map&lt;String, RemoteReplyService.ReplyStatus&gt;&gt;(emptyMap()) }&#10;    var sendingMessages by remember { mutableStateOf&lt;Map&lt;String, String&gt;&gt;(emptyMap()) }&#10;&#10;    // Broadcast receiver for reply status updates&#10;    val replyStatusReceiver = remember {&#10;        object : BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                when (intent?.action) {&#10;                    &quot;com.example.jawafai.REPLY_STATUS&quot; -&gt; {&#10;                        val conversationId = intent.getStringExtra(&quot;conversationId&quot;) ?: return&#10;                        val status = intent.getStringExtra(&quot;status&quot;) ?: return&#10;                        val message = intent.getStringExtra(&quot;message&quot;)&#10;&#10;                        sendingStatus = sendingStatus.toMutableMap().apply {&#10;                            this[conversationId] = RemoteReplyService.ReplyStatus.valueOf(status)&#10;                        }&#10;&#10;                        if (message != null) {&#10;                            sendingMessages = sendingMessages.toMutableMap().apply {&#10;                                this[conversationId] = message&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Register broadcast receiver&#10;    LaunchedEffect(Unit) {&#10;        val filter = IntentFilter(&quot;com.example.jawafai.REPLY_STATUS&quot;)&#10;        LocalBroadcastManager.getInstance(context).registerReceiver(replyStatusReceiver, filter)&#10;    }&#10;&#10;    // Cleanup receiver&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            try {&#10;                LocalBroadcastManager.getInstance(context).unregisterReceiver(replyStatusReceiver)&#10;            } catch (e: Exception) {&#10;                // Receiver might already be unregistered&#10;            }&#10;        }&#10;    }&#10;&#10;    // Observe external notifications from NotificationMemoryStore&#10;    val externalNotifications by remember {&#10;        derivedStateOf {&#10;            NotificationMemoryStore.getAllNotifications()&#10;        }&#10;    }&#10;&#10;    // Map external notifications to ChatNotification for display&#10;    val liveNotifications = remember(externalNotifications) {&#10;        externalNotifications.map { notification -&gt;&#10;            ChatNotification(&#10;                id = notification.hash,&#10;                platform = when {&#10;                    notification.packageName.contains(&quot;whatsapp&quot;, true) -&gt; ChatPlatform.WHATSAPP&#10;                    notification.packageName.contains(&quot;instagram&quot;, true) -&gt; ChatPlatform.INSTAGRAM&#10;                    notification.packageName.contains(&quot;messenger&quot;, true) ||&#10;                    notification.packageName.contains(&quot;facebook.orca&quot;, true) -&gt; ChatPlatform.MESSENGER&#10;                    else -&gt; ChatPlatform.GENERAL&#10;                },&#10;                senderName = notification.sender?.takeIf { it.isNotBlank() } ?: notification.title.ifBlank { notification.packageName },&#10;                senderAvatar = null,&#10;                message = notification.text,&#10;                timestamp = notification.time,&#10;                isRead = false,&#10;                hasGeneratedReply = notification.ai_reply.isNotBlank(),&#10;                generatedReply = notification.ai_reply,&#10;                hasReplyAction = notification.hasReplyAction,&#10;                isSent = notification.is_sent,&#10;                conversationId = notification.conversationId,&#10;                notificationHash = notification.hash&#10;            )&#10;        }&#10;    }&#10;&#10;    // Filter notifications based on search and platform filter&#10;    val filteredNotifications = remember(selectedFilter, liveNotifications) {&#10;        liveNotifications.filter { notification -&gt;&#10;            val matchesFilter = selectedFilter?.let { filter -&gt;&#10;                notification.platform == filter&#10;            } ?: true&#10;&#10;            matchesFilter&#10;        }&#10;    }&#10;&#10;    // Function to generate AI reply with enhanced debugging&#10;    fun generateAIReply(notificationHash: String) {&#10;        coroutineScope.launch {&#10;            try {&#10;                Log.d(&quot;NotificationScreen&quot;, &quot; Starting AI reply generation for hash: $notificationHash&quot;)&#10;                generatingReplyFor = notificationHash&#10;&#10;                // Get the notification from memory store&#10;                val notification = NotificationMemoryStore.getAllNotifications()&#10;                    .find { it.hash == notificationHash }&#10;&#10;                if (notification == null) {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ Notification not found in memory store&quot;)&#10;                    Toast.makeText(context, &quot;Error: Notification not found&quot;, Toast.LENGTH_SHORT).show()&#10;                    return@launch&#10;                }&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot;✅ Found notification: ${notification.text}&quot;)&#10;&#10;                // Check if API key is configured&#10;                if (!GroqApiManager.isApiKeyConfigured()) {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ Groq API key not configured&quot;)&#10;                    Toast.makeText(context, &quot;Error: API key not configured. Please check your settings.&quot;, Toast.LENGTH_LONG).show()&#10;                    return@launch&#10;                }&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot;✅ API key configured, generating reply...&quot;)&#10;                Toast.makeText(context, &quot;Generating AI reply...&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                // Generate AI reply&#10;                val result = NotificationAIReplyManager.generateAIReply(&#10;                    notification = notification,&#10;                    userPersona = null, // You can pass user persona here&#10;                    context = context&#10;                )&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot; AI reply result: success=${result.success}, error=${result.error}&quot;)&#10;&#10;                if (result.success &amp;&amp; result.reply != null) {&#10;                    Log.d(&quot;NotificationScreen&quot;, &quot;✅ AI reply generated successfully: ${result.reply.take(100)}...&quot;)&#10;                    Toast.makeText(context, &quot;AI reply generated successfully! &quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ AI reply generation failed: ${result.error}&quot;)&#10;                    val errorMessage = when {&#10;                        result.error?.contains(&quot;API key not configured&quot;) == true -&gt;&#10;                            &quot;Please configure your Groq API key in settings&quot;&#10;                        result.error?.contains(&quot;401&quot;) == true -&gt;&#10;                            &quot;Invalid API key. Please check your configuration.&quot;&#10;                        result.error?.contains(&quot;429&quot;) == true -&gt;&#10;                            &quot;Rate limit exceeded. Please try again later.&quot;&#10;                        result.error?.contains(&quot;network&quot;) == true -&gt;&#10;                            &quot;Network error. Please check your connection.&quot;&#10;                        result.error?.contains(&quot;timeout&quot;) == true -&gt;&#10;                            &quot;Request timeout. Please try again.&quot;&#10;                        else -&gt;&#10;                            &quot;Failed to generate reply: ${result.error ?: &quot;Unknown error&quot;}&quot;&#10;                    }&#10;                    Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;NotificationScreen&quot;, &quot;❌ Exception in AI reply generation: ${e.message}&quot;, e)&#10;                Toast.makeText(context, &quot;Error generating reply: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            } finally {&#10;                generatingReplyFor = null&#10;            }&#10;        }&#10;    }&#10;&#10;    // Enhanced function to send reply with status tracking&#10;    fun sendReply(conversationId: String, replyText: String) {&#10;        coroutineScope.launch {&#10;            try {&#10;                // Use RemoteReplyService to send the reply with retry mechanism&#10;                val result = RemoteReplyService.sendReply(&#10;                    context = context,&#10;                    conversationId = conversationId,&#10;                    replyText = replyText&#10;                )&#10;&#10;                if (result.success) {&#10;                    Toast.makeText(context, &quot;Reply sent successfully! &quot;, Toast.LENGTH_SHORT).show()&#10;                    // Clear any error messages&#10;                    sendingMessages = sendingMessages.toMutableMap().apply {&#10;                        remove(conversationId)&#10;                    }&#10;                } else {&#10;                    val errorMessage = when {&#10;                        result.error?.contains(&quot;No notification with reply action&quot;) == true -&gt;&#10;                            &quot;Cannot send reply: This notification doesn't support direct replies.&quot;&#10;                        result.canRetry -&gt;&#10;                            &quot;Failed to send reply after ${RemoteReplyService.MAX_RETRY_ATTEMPTS} attempts: ${result.error}&quot;&#10;                        else -&gt;&#10;                            &quot;Failed to send reply: ${result.error}&quot;&#10;                    }&#10;                    Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(context, &quot;Error sending reply: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Manual retry function&#10;    fun retryReply(conversationId: String, replyText: String) {&#10;        // Clear previous status&#10;        RemoteReplyService.clearSendingStatus(conversationId)&#10;        sendingStatus = sendingStatus.toMutableMap().apply {&#10;            remove(conversationId)&#10;        }&#10;        sendingMessages = sendingMessages.toMutableMap().apply {&#10;            remove(conversationId)&#10;        }&#10;&#10;        // Retry sending&#10;        sendReply(conversationId, replyText)&#10;    }&#10;&#10;    // Pull to refresh simulation&#10;    LaunchedEffect(isRefreshing) {&#10;        if (isRefreshing) {&#10;            delay(1000) // Simulate refresh&#10;            isRefreshing = false&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White),&#10;        containerColor = Color.White,&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Smart Notifications&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 24.sp,&#10;                            color = Color(0xFF395B64)&#10;                        )&#10;                    )&#10;                },&#10;                actions = {&#10;                    IconButton(&#10;                        onClick = {&#10;                            // Clear notification memory store&#10;                            NotificationMemoryStore.clear()&#10;                            Toast.makeText(context, &quot;Notifications cleared&quot;, Toast.LENGTH_SHORT).show()&#10;                            isRefreshing = true&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.Refresh,&#10;                            contentDescription = &quot;Clear notifications&quot;,&#10;                            tint = Color(0xFF395B64)&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(Color.White)&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Platform Filter Chips&#10;            LazyRow(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                contentPadding = PaddingValues(vertical = 8.dp)&#10;            ) {&#10;                item {&#10;                    FilterChip(&#10;                        onClick = { selectedFilter = null },&#10;                        label = { Text(&quot;All&quot;) },&#10;                        selected = selectedFilter == null,&#10;                        colors = FilterChipDefaults.filterChipColors(&#10;                            selectedContainerColor = Color(0xFF395B64),&#10;                            selectedLabelColor = Color.White&#10;                        )&#10;                    )&#10;                }&#10;&#10;                items(ChatPlatform.values().toList()) { platform -&gt;&#10;                    FilterChip(&#10;                        onClick = {&#10;                            selectedFilter = if (selectedFilter == platform) null else platform&#10;                        },&#10;                        label = { Text(platform.displayName) },&#10;                        selected = selectedFilter == platform,&#10;                        colors = FilterChipDefaults.filterChipColors(&#10;                            selectedContainerColor = platform.color,&#10;                            selectedLabelColor = Color.White&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Loading indicator&#10;            AnimatedVisibility(visible = isRefreshing) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 16.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        color = Color(0xFF395B64),&#10;                        modifier = Modifier.size(32.dp),&#10;                        strokeWidth = 3.dp&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Notifications List&#10;            if (filteredNotifications.isEmpty()) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Notifications,&#10;                            contentDescription = &quot;No notifications&quot;,&#10;                            modifier = Modifier.size(48.dp),&#10;                            tint = Color(0xFF666666).copy(alpha = 0.5f)&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        Text(&#10;                            text = &quot;No notifications yet&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF666666)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    items(filteredNotifications) { notification -&gt;&#10;                        EnhancedNotificationCard(&#10;                            notification = notification,&#10;                            onGenerateReply = { generateAIReply(notification.notificationHash) },&#10;                            onSendReply = { sendReply(notification.conversationId, notification.generatedReply) },&#10;                            onMarkAsRead = { /* Handle mark as read */ },&#10;                            isGeneratingReply = generatingReplyFor == notification.notificationHash,&#10;                            sendingStatus = sendingStatus[notification.conversationId],&#10;                            sentMessage = sendingMessages[notification.conversationId]&#10;                        )&#10;                    }&#10;&#10;                    item {&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnhancedNotificationCard(&#10;    notification: ChatNotification,&#10;    onGenerateReply: () -&gt; Unit,&#10;    onSendReply: () -&gt; Unit,&#10;    onMarkAsRead: (String) -&gt; Unit,&#10;    isGeneratingReply: Boolean,&#10;    sendingStatus: RemoteReplyService.ReplyStatus?,&#10;    sentMessage: String?&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (notification.isRead) Color.White else Color(0xFFF0F8FF)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header with platform and timestamp&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(notification.platform.color)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = notification.platform.displayName,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontSize = 12.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = notification.platform.color&#10;                        )&#10;                    )&#10;&#10;                    // Reply action indicator&#10;                    if (notification.hasReplyAction) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Icon(&#10;                            imageVector = Icons.Default.Reply,&#10;                            contentDescription = &quot;Reply Available&quot;,&#10;                            modifier = Modifier.size(12.dp),&#10;                            tint = Color(0xFF4CAF50)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Text(&#10;                    text = formatTimestamp(notification.timestamp),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF666666)&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Sender and message&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                // Avatar&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(48.dp)&#10;                        .clip(CircleShape)&#10;                        .background(Color(0xFFA5C9CA))&#10;                ) {&#10;                    if (notification.senderAvatar != null) {&#10;                        AsyncImage(&#10;                            model = notification.senderAvatar,&#10;                            contentDescription = &quot;Sender Avatar&quot;,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentScale = ContentScale.Crop&#10;                        )&#10;                    } else {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Person,&#10;                            contentDescription = &quot;Default Avatar&quot;,&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                // Message content&#10;                Column(&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&#10;                        text = notification.senderName,&#10;                        style = MaterialTheme.typography.bodyLarge.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF395B64)&#10;                        )&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                    Text(&#10;                        text = notification.message,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF666666)&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;&#10;                // Unread indicator&#10;                if (!notification.isRead) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(Color(0xFF395B64))&#10;                    )&#10;                }&#10;            }&#10;&#10;            // AI Generated Reply Section&#10;            if (notification.hasGeneratedReply &amp;&amp; notification.generatedReply.isNotBlank()) {&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFFF0F8FF).copy(alpha = 0.7f)&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(12.dp)&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AutoAwesome,&#10;                                contentDescription = &quot;AI Generated&quot;,&#10;                                modifier = Modifier.size(16.dp),&#10;                                tint = Color(0xFF395B64)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                text = &quot;AI Generated Reply&quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = AppFonts.KarlaFontFamily,&#10;                                    fontSize = 12.sp,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = Color(0xFF395B64)&#10;                                )&#10;                            )&#10;&#10;                            // Status indicators&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;&#10;                            when (sendingStatus) {&#10;                                RemoteReplyService.ReplyStatus.SENDING -&gt; {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        strokeWidth = 2.dp,&#10;                                        color = Color(0xFF2196F3)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Sending...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF2196F3)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.RETRYING -&gt; {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        strokeWidth = 2.dp,&#10;                                        color = Color(0xFFFF9800)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Retrying...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFFFF9800)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.SENT -&gt; {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.CheckCircle,&#10;                                        contentDescription = &quot;Sent&quot;,&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        tint = Color(0xFF4CAF50)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Sent&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF4CAF50)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.FAILED -&gt; {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Error,&#10;                                        contentDescription = &quot;Failed&quot;,&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        tint = Color(0xFFE53E3E)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Failed&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFFE53E3E)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                else -&gt; {&#10;                                    if (notification.isSent) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.CheckCircle,&#10;                                            contentDescription = &quot;Sent&quot;,&#10;                                            modifier = Modifier.size(16.dp),&#10;                                            tint = Color(0xFF4CAF50)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = notification.generatedReply,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFF333333)&#10;                            )&#10;                        )&#10;&#10;                        // Show status message if available&#10;                        if (sentMessage != null) {&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                            Text(&#10;                                text = sentMessage,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontSize = 11.sp,&#10;                                    color = when (sendingStatus) {&#10;                                        RemoteReplyService.ReplyStatus.FAILED -&gt; Color(0xFFE53E3E)&#10;                                        RemoteReplyService.ReplyStatus.RETRYING -&gt; Color(0xFFFF9800)&#10;                                        else -&gt; Color(0xFF666666)&#10;                                    }&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Action buttons&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                // Generate Reply Button&#10;                if (!notification.hasGeneratedReply &amp;&amp; !isGeneratingReply) {&#10;                    Button(&#10;                        onClick = onGenerateReply,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.AutoAwesome,&#10;                            contentDescription = &quot;Generate Reply&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Generate Reply&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Loading state for reply generation&#10;                if (isGeneratingReply) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while generating */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF395B64).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Generating...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Regenerate Reply Button (if reply exists and not currently sending)&#10;                if (notification.hasGeneratedReply &amp;&amp;&#10;                    !isGeneratingReply &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.SENDING &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.RETRYING) {&#10;&#10;                    OutlinedButton(&#10;                        onClick = onGenerateReply,&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            contentColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.widthIn(min = 120.dp),&#10;                        contentPadding = PaddingValues(horizontal = 12.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Regenerate&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Regenerate&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 11.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Spacer to push send button to the right&#10;                Spacer(modifier = Modifier.weight(1f))&#10;&#10;                // Send Reply Button (moved to the right side)&#10;                if (notification.hasGeneratedReply &amp;&amp;&#10;                    notification.hasReplyAction &amp;&amp;&#10;                    !notification.isSent &amp;&amp;&#10;                    !isGeneratingReply &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.SENDING &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.RETRYING) {&#10;&#10;                    Button(&#10;                        onClick = onSendReply,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF4CAF50)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Send,&#10;                            contentDescription = &quot;Send Reply&quot;,&#10;                            modifier = Modifier.size(18.dp),&#10;                            tint = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Send&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Sending state button&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.SENDING) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while sending */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF2196F3).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Sending...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Retrying state button&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.RETRYING) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while retrying */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFFF9800).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Retrying...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Retry button for failed sends&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.FAILED) {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                // Retry sending&#10;                                RemoteReplyService.sendReply(&#10;                                    context = context,&#10;                                    conversationId = notification.conversationId,&#10;                                    replyText = notification.generatedReply&#10;                                )&#10;                            }&#10;                        },&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFE53E3E)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Retry&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Retry&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Helper function to format timestamps&#10;@Composable&#10;fun formatTimestamp(timestamp: Long): String {&#10;    val now = System.currentTimeMillis()&#10;    val diff = now - timestamp&#10;&#10;    return when {&#10;        diff &lt; 60 * 1000 -&gt; &quot;now&quot;&#10;        diff &lt; 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 1000)}m ago&quot;&#10;        diff &lt; 24 * 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 60 * 1000)}h ago&quot;&#10;        diff &lt; 48 * 60 * 60 * 1000 -&gt; &quot;yesterday&quot;&#10;        else -&gt; {&#10;            SimpleDateFormat(&quot;MMM dd&quot;, Locale.getDefault()).format(Date(timestamp))&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.jawafai.view.dashboard.notifications&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.ClipData&#10;import android.content.ClipboardManager&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.OnBackPressedCallback&#10;import androidx.activity.compose.LocalOnBackPressedDispatcherOwner&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.TabRowDefaults.tabIndicatorOffset&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager&#10;import coil.compose.AsyncImage&#10;import com.example.jawafai.R&#10;import com.example.jawafai.managers.GroqApiManager&#10;import com.example.jawafai.service.NotificationMemoryStore&#10;import com.example.jawafai.service.NotificationAIReplyManager&#10;import com.example.jawafai.service.SmartReplyAIModule&#10;import com.example.jawafai.service.RemoteReplyService&#10;import com.example.jawafai.ui.theme.AppFonts&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;// Data classes for chat notifications&#10;data class ChatNotification(&#10;    val id: String,&#10;    val platform: ChatPlatform,&#10;    val senderName: String,&#10;    val senderAvatar: String?,&#10;    val message: String,&#10;    val timestamp: Long,&#10;    val isRead: Boolean,&#10;    val hasGeneratedReply: Boolean = false,&#10;    val generatedReply: String = &quot;&quot;,&#10;    val hasReplyAction: Boolean = false,&#10;    val isSent: Boolean = false,&#10;    val conversationId: String = &quot;&quot;,&#10;    val notificationHash: String = &quot;&quot;&#10;)&#10;&#10;enum class ChatPlatform(&#10;    val displayName: String,&#10;    val color: Color,&#10;    val iconRes: Int? = null&#10;) {&#10;    WHATSAPP(&quot;WhatsApp&quot;, Color(0xFF25D366)),&#10;    INSTAGRAM(&quot;Instagram&quot;, Color(0xFFE4405F)),&#10;    MESSENGER(&quot;Messenger&quot;, Color(0xFF0084FF)),&#10;    GENERAL(&quot;General&quot;, Color(0xFF395B64))&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun NotificationScreen(&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val backDispatcher = LocalOnBackPressedDispatcherOwner.current?.onBackPressedDispatcher&#10;&#10;    // State management&#10;    var isRefreshing by remember { mutableStateOf(false) }&#10;    var selectedFilter by remember { mutableStateOf&lt;ChatPlatform?&gt;(null) }&#10;    var generatingReplyFor by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var selectedTab by remember { mutableStateOf(0) } // 0 = Smart, 1 = Raw&#10;&#10;    // Send status tracking&#10;    var sendingStatus by remember { mutableStateOf&lt;Map&lt;String, RemoteReplyService.ReplyStatus&gt;&gt;(emptyMap()) }&#10;    var sendingMessages by remember { mutableStateOf&lt;Map&lt;String, String&gt;&gt;(emptyMap()) }&#10;&#10;    // Broadcast receiver for reply status updates&#10;    val replyStatusReceiver = remember {&#10;        object : BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                when (intent?.action) {&#10;                    &quot;com.example.jawafai.REPLY_STATUS&quot; -&gt; {&#10;                        val conversationId = intent.getStringExtra(&quot;conversationId&quot;) ?: return&#10;                        val status = intent.getStringExtra(&quot;status&quot;) ?: return&#10;                        val message = intent.getStringExtra(&quot;message&quot;)&#10;&#10;                        sendingStatus = sendingStatus.toMutableMap().apply {&#10;                            this[conversationId] = RemoteReplyService.ReplyStatus.valueOf(status)&#10;                        }&#10;&#10;                        if (message != null) {&#10;                            sendingMessages = sendingMessages.toMutableMap().apply {&#10;                                this[conversationId] = message&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Register broadcast receiver&#10;    LaunchedEffect(Unit) {&#10;        val filter = IntentFilter(&quot;com.example.jawafai.REPLY_STATUS&quot;)&#10;        LocalBroadcastManager.getInstance(context).registerReceiver(replyStatusReceiver, filter)&#10;    }&#10;&#10;    // Cleanup receiver&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            try {&#10;                LocalBroadcastManager.getInstance(context).unregisterReceiver(replyStatusReceiver)&#10;            } catch (e: Exception) {&#10;                // Receiver might already be unregistered&#10;            }&#10;        }&#10;    }&#10;&#10;    // Observe external notifications from NotificationMemoryStore&#10;    val externalNotifications by remember {&#10;        derivedStateOf {&#10;            NotificationMemoryStore.getAllNotifications()&#10;        }&#10;    }&#10;&#10;    // Observe conversations from NotificationMemoryStore&#10;    val conversations by remember {&#10;        derivedStateOf {&#10;            NotificationMemoryStore.getAllConversations()&#10;        }&#10;    }&#10;&#10;    // State for selected conversation (null = showing inbox)&#10;    var selectedConversation by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Map external notifications to ChatNotification for display (kept for compatibility)&#10;    val liveNotifications = remember(externalNotifications) {&#10;        externalNotifications.map { notification -&gt;&#10;            ChatNotification(&#10;                id = notification.hash,&#10;                platform = when {&#10;                    notification.packageName.contains(&quot;whatsapp&quot;, true) -&gt; ChatPlatform.WHATSAPP&#10;                    notification.packageName.contains(&quot;instagram&quot;, true) -&gt; ChatPlatform.INSTAGRAM&#10;                    notification.packageName.contains(&quot;messenger&quot;, true) ||&#10;                    notification.packageName.contains(&quot;facebook.orca&quot;, true) -&gt; ChatPlatform.MESSENGER&#10;                    else -&gt; ChatPlatform.GENERAL&#10;                },&#10;                senderName = notification.sender?.takeIf { it.isNotBlank() } ?: notification.title.ifBlank { notification.packageName },&#10;                senderAvatar = null,&#10;                message = notification.text,&#10;                timestamp = notification.time,&#10;                isRead = false,&#10;                hasGeneratedReply = notification.ai_reply.isNotBlank(),&#10;                generatedReply = notification.ai_reply,&#10;                hasReplyAction = notification.hasReplyAction,&#10;                isSent = notification.is_sent,&#10;                conversationId = notification.conversationId,&#10;                notificationHash = notification.hash&#10;            )&#10;        }&#10;    }&#10;&#10;    // Filter notifications based on search and platform filter&#10;    val filteredNotifications = remember(selectedFilter, liveNotifications) {&#10;        liveNotifications.filter { notification -&gt;&#10;            val matchesFilter = selectedFilter?.let { filter -&gt;&#10;                notification.platform == filter&#10;            } ?: true&#10;&#10;            matchesFilter&#10;        }&#10;    }&#10;&#10;    // Function to generate AI reply with enhanced debugging&#10;    fun generateAIReply(notificationHash: String) {&#10;        coroutineScope.launch {&#10;            try {&#10;                Log.d(&quot;NotificationScreen&quot;, &quot; Starting AI reply generation for hash: $notificationHash&quot;)&#10;                generatingReplyFor = notificationHash&#10;&#10;                // Get the notification from memory store&#10;                val notification = NotificationMemoryStore.getAllNotifications()&#10;                    .find { it.hash == notificationHash }&#10;&#10;                if (notification == null) {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ Notification not found in memory store&quot;)&#10;                    Toast.makeText(context, &quot;Error: Notification not found&quot;, Toast.LENGTH_SHORT).show()&#10;                    return@launch&#10;                }&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot;✅ Found notification: ${notification.text}&quot;)&#10;&#10;                // Check if API key is configured&#10;                if (!GroqApiManager.isApiKeyConfigured()) {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ Groq API key not configured&quot;)&#10;                    Toast.makeText(context, &quot;Error: API key not configured. Please check your settings.&quot;, Toast.LENGTH_LONG).show()&#10;                    return@launch&#10;                }&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot;✅ API key configured, generating reply...&quot;)&#10;                Toast.makeText(context, &quot;Generating AI reply...&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                // Generate AI reply&#10;                val result = NotificationAIReplyManager.generateAIReply(&#10;                    notification = notification,&#10;                    userPersona = null, // You can pass user persona here&#10;                    context = context&#10;                )&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot; AI reply result: success=${result.success}, error=${result.error}&quot;)&#10;&#10;                if (result.success &amp;&amp; result.reply != null) {&#10;                    Log.d(&quot;NotificationScreen&quot;, &quot;✅ AI reply generated successfully: ${result.reply.take(100)}...&quot;)&#10;                    Toast.makeText(context, &quot;AI reply generated successfully! &quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ AI reply generation failed: ${result.error}&quot;)&#10;                    val errorMessage = when {&#10;                        result.error?.contains(&quot;API key not configured&quot;) == true -&gt;&#10;                            &quot;Please configure your Groq API key in settings&quot;&#10;                        result.error?.contains(&quot;401&quot;) == true -&gt;&#10;                            &quot;Invalid API key. Please check your configuration.&quot;&#10;                        result.error?.contains(&quot;429&quot;) == true -&gt;&#10;                            &quot;Rate limit exceeded. Please try again later.&quot;&#10;                        result.error?.contains(&quot;network&quot;) == true -&gt;&#10;                            &quot;Network error. Please check your connection.&quot;&#10;                        result.error?.contains(&quot;timeout&quot;) == true -&gt;&#10;                            &quot;Request timeout. Please try again.&quot;&#10;                        else -&gt;&#10;                            &quot;Failed to generate reply: ${result.error ?: &quot;Unknown error&quot;}&quot;&#10;                    }&#10;                    Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;NotificationScreen&quot;, &quot;❌ Exception in AI reply generation: ${e.message}&quot;, e)&#10;                Toast.makeText(context, &quot;Error generating reply: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            } finally {&#10;                generatingReplyFor = null&#10;            }&#10;        }&#10;    }&#10;&#10;    // Enhanced function to send reply with status tracking&#10;    fun sendReply(conversationId: String, replyText: String) {&#10;        coroutineScope.launch {&#10;            try {&#10;                // Use RemoteReplyService to send the reply with retry mechanism&#10;                val result = RemoteReplyService.sendReply(&#10;                    context = context,&#10;                    conversationId = conversationId,&#10;                    replyText = replyText&#10;                )&#10;&#10;                if (result.success) {&#10;                    Toast.makeText(context, &quot;Reply sent successfully! &quot;, Toast.LENGTH_SHORT).show()&#10;                    // Clear any error messages&#10;                    sendingMessages = sendingMessages.toMutableMap().apply {&#10;                        remove(conversationId)&#10;                    }&#10;                } else {&#10;                    val errorMessage = when {&#10;                        result.error?.contains(&quot;No notification with reply action&quot;) == true -&gt;&#10;                            &quot;Cannot send reply: This notification doesn't support direct replies.&quot;&#10;                        result.canRetry -&gt;&#10;                            &quot;Failed to send reply after ${RemoteReplyService.MAX_RETRY_ATTEMPTS} attempts: ${result.error}&quot;&#10;                        else -&gt;&#10;                            &quot;Failed to send reply: ${result.error}&quot;&#10;                    }&#10;                    Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(context, &quot;Error sending reply: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Manual retry function&#10;    fun retryReply(conversationId: String, replyText: String) {&#10;        // Clear previous status&#10;        RemoteReplyService.clearSendingStatus(conversationId)&#10;        sendingStatus = sendingStatus.toMutableMap().apply {&#10;            remove(conversationId)&#10;        }&#10;        sendingMessages = sendingMessages.toMutableMap().apply {&#10;            remove(conversationId)&#10;        }&#10;&#10;        // Retry sending&#10;        sendReply(conversationId, replyText)&#10;    }&#10;&#10;    // Pull to refresh simulation&#10;    LaunchedEffect(isRefreshing) {&#10;        if (isRefreshing) {&#10;            delay(1000) // Simulate refresh&#10;            isRefreshing = false&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White),&#10;        containerColor = Color.White,&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Smart Notifications&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 24.sp,&#10;                            color = Color(0xFF395B64)&#10;                        )&#10;                    )&#10;                },&#10;                actions = {&#10;                    IconButton(&#10;                        onClick = {&#10;                            // Clear notification memory store&#10;                            NotificationMemoryStore.clear()&#10;                            Toast.makeText(context, &quot;Notifications cleared&quot;, Toast.LENGTH_SHORT).show()&#10;                            isRefreshing = true&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.Refresh,&#10;                            contentDescription = &quot;Clear notifications&quot;,&#10;                            tint = Color(0xFF395B64)&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(Color.White)&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Tab Row for Smart vs Raw&#10;            TabRow(&#10;                selectedTabIndex = selectedTab,&#10;                containerColor = Color.White,&#10;                contentColor = Color(0xFF395B64),&#10;                indicator = { tabPositions -&gt;&#10;                    TabRowDefaults.Indicator(&#10;                        Modifier.tabIndicatorOffset(tabPositions[selectedTab]),&#10;                        color = Color(0xFF395B64)&#10;                    )&#10;                }&#10;            ) {&#10;                Tab(&#10;                    selected = selectedTab == 0,&#10;                    onClick = { selectedTab = 0 },&#10;                    text = {&#10;                        Text(&#10;                            text = &quot;Smart&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontWeight = if (selectedTab == 0) FontWeight.Bold else FontWeight.Normal&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;                Tab(&#10;                    selected = selectedTab == 1,&#10;                    onClick = { selectedTab = 1 },&#10;                    text = {&#10;                        Text(&#10;                            text = &quot;Raw&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontWeight = if (selectedTab == 1) FontWeight.Bold else FontWeight.Normal&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Conditional rendering based on selected tab&#10;            when (selectedTab) {&#10;                0 -&gt; {&#10;                    // Smart Tab (conversation-based view)&#10;                    SmartNotificationsContent(&#10;                        conversations = conversations,&#10;                        selectedConversation = selectedConversation,&#10;                        onConversationClick = { convoId -&gt;&#10;                            selectedConversation = convoId&#10;                            NotificationMemoryStore.markConversationAsRead(convoId)&#10;                        },&#10;                        onBackToInbox = { selectedConversation = null },&#10;                        selectedFilter = selectedFilter,&#10;                        onFilterChange = { selectedFilter = it },&#10;                        isRefreshing = isRefreshing,&#10;                        generatingReplyFor = generatingReplyFor,&#10;                        sendingStatus = sendingStatus,&#10;                        sendingMessages = sendingMessages,&#10;                        onGenerateReply = { notificationHash -&gt; generateAIReply(notificationHash) },&#10;                        onSendReply = { conversationId, replyText -&gt; sendReply(conversationId, replyText) }&#10;                    )&#10;                }&#10;                1 -&gt; {&#10;                    // Raw Tab (new functionality)&#10;                    RawNotificationsContent(&#10;                        notifications = externalNotifications&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SmartNotificationsContent(&#10;    conversations: List&lt;NotificationMemoryStore.Conversation&gt;,&#10;    selectedConversation: String?,&#10;    onConversationClick: (String) -&gt; Unit,&#10;    onBackToInbox: () -&gt; Unit,&#10;    selectedFilter: ChatPlatform?,&#10;    onFilterChange: (ChatPlatform?) -&gt; Unit,&#10;    isRefreshing: Boolean,&#10;    generatingReplyFor: String?,&#10;    sendingStatus: Map&lt;String, RemoteReplyService.ReplyStatus&gt;,&#10;    sendingMessages: Map&lt;String, String&gt;,&#10;    onGenerateReply: (String) -&gt; Unit,&#10;    onSendReply: (String, String) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        if (selectedConversation == null) {&#10;            // Show Inbox (list of conversations)&#10;            ConversationInboxView(&#10;                conversations = conversations,&#10;                selectedFilter = selectedFilter,&#10;                onFilterChange = onFilterChange,&#10;                isRefreshing = isRefreshing,&#10;                onConversationClick = onConversationClick&#10;            )&#10;        } else {&#10;            // Show Chat View (messages in selected conversation)&#10;            ConversationChatView(&#10;                conversationId = selectedConversation,&#10;                onBackClick = onBackToInbox,&#10;                generatingReplyFor = generatingReplyFor,&#10;                sendingStatus = sendingStatus,&#10;                sendingMessages = sendingMessages,&#10;                onGenerateReply = onGenerateReply,&#10;                onSendReply = onSendReply&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ConversationInboxView(&#10;    conversations: List&lt;NotificationMemoryStore.Conversation&gt;,&#10;    selectedFilter: ChatPlatform?,&#10;    onFilterChange: (ChatPlatform?) -&gt; Unit,&#10;    isRefreshing: Boolean,&#10;    onConversationClick: (String) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;            // Platform Filter Chips&#10;            LazyRow(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                contentPadding = PaddingValues(vertical = 8.dp)&#10;            ) {&#10;                item {&#10;                    FilterChip(&#10;                        onClick = { onFilterChange(null) },&#10;                        label = { Text(&quot;All&quot;) },&#10;                        selected = selectedFilter == null,&#10;                        colors = FilterChipDefaults.filterChipColors(&#10;                            selectedContainerColor = Color(0xFF395B64),&#10;                            selectedLabelColor = Color.White&#10;                        )&#10;                    )&#10;                }&#10;&#10;                items(ChatPlatform.entries.toList()) { platform -&gt;&#10;                    FilterChip(&#10;                        onClick = {&#10;                            onFilterChange(if (selectedFilter == platform) null else platform)&#10;                        },&#10;                        label = { Text(platform.displayName) },&#10;                        selected = selectedFilter == platform,&#10;                        colors = FilterChipDefaults.filterChipColors(&#10;                            selectedContainerColor = platform.color,&#10;                            selectedLabelColor = Color.White&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Loading indicator&#10;            AnimatedVisibility(visible = isRefreshing) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 16.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        color = Color(0xFF395B64),&#10;                        modifier = Modifier.size(32.dp),&#10;                        strokeWidth = 3.dp&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Filter conversations by selected platform&#10;            val filteredConversations = remember(conversations, selectedFilter) {&#10;                if (selectedFilter == null) {&#10;                    conversations&#10;                } else {&#10;                    conversations.filter { convo -&gt;&#10;                        when (selectedFilter) {&#10;                            ChatPlatform.WHATSAPP -&gt; convo.package_name.contains(&quot;whatsapp&quot;, true)&#10;                            ChatPlatform.INSTAGRAM -&gt; convo.package_name.contains(&quot;instagram&quot;, true)&#10;                            ChatPlatform.MESSENGER -&gt; convo.package_name.contains(&quot;messenger&quot;, true) ||&#10;                                                     convo.package_name.contains(&quot;facebook.orca&quot;, true)&#10;                            ChatPlatform.GENERAL -&gt; !convo.package_name.contains(&quot;whatsapp&quot;, true) &amp;&amp;&#10;                                                   !convo.package_name.contains(&quot;instagram&quot;, true) &amp;&amp;&#10;                                                   !convo.package_name.contains(&quot;messenger&quot;, true)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Conversations List (Inbox)&#10;            if (filteredConversations.isEmpty()) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Forum,&#10;                            contentDescription = &quot;No conversations&quot;,&#10;                            modifier = Modifier.size(48.dp),&#10;                            tint = Color(0xFF666666).copy(alpha = 0.5f)&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        Text(&#10;                            text = &quot;No conversations yet&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF666666)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    items(filteredConversations) { conversation -&gt;&#10;                        ConversationInboxItem(&#10;                            conversation = conversation,&#10;                            onClick = { onConversationClick(conversation.convo_id) }&#10;                        )&#10;                    }&#10;&#10;                    item {&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                    }&#10;                }&#10;            }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ConversationInboxItem(&#10;    conversation: NotificationMemoryStore.Conversation,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    val platform = when {&#10;        conversation.package_name.contains(&quot;whatsapp&quot;, true) -&gt; ChatPlatform.WHATSAPP&#10;        conversation.package_name.contains(&quot;instagram&quot;, true) -&gt; ChatPlatform.INSTAGRAM&#10;        conversation.package_name.contains(&quot;messenger&quot;, true) ||&#10;        conversation.package_name.contains(&quot;facebook.orca&quot;, true) -&gt; ChatPlatform.MESSENGER&#10;        else -&gt; ChatPlatform.GENERAL&#10;    }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() },&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (conversation.unread_count &gt; 0) Color(0xFFF0F8FF) else Color.White&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Avatar with platform indicator&#10;            Box {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(56.dp)&#10;                        .clip(CircleShape)&#10;                        .background(Color(0xFFA5C9CA)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = conversation.display_name.firstOrNull()?.uppercase() ?: &quot;?&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Color.White&#10;                        )&#10;                    )&#10;                }&#10;&#10;                // Platform badge&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(20.dp)&#10;                        .align(Alignment.BottomEnd)&#10;                        .clip(CircleShape)&#10;                        .background(platform.color),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(18.dp)&#10;                            .clip(CircleShape)&#10;                            .background(platform.color)&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;&#10;            // Conversation details&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = conversation.display_name,&#10;                        style = MaterialTheme.typography.bodyLarge.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = if (conversation.unread_count &gt; 0) FontWeight.Bold else FontWeight.Normal,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF395B64)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis,&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    Text(&#10;                        text = formatTimestamp(conversation.last_msg_time),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF666666)&#10;                        )&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = conversation.last_msg_content,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 14.sp,&#10;                            fontWeight = if (conversation.unread_count &gt; 0) FontWeight.Medium else FontWeight.Normal,&#10;                            color = if (conversation.unread_count &gt; 0) Color(0xFF333333) else Color(0xFF666666)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis,&#10;                        modifier = Modifier.weight(1f)&#10;                    )&#10;&#10;                    // Unread count badge&#10;                    if (conversation.unread_count &gt; 0) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .clip(CircleShape)&#10;                                .background(Color(0xFF395B64))&#10;                                .padding(horizontal = 8.dp, vertical = 4.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = conversation.unread_count.toString(),&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = AppFonts.KarlaFontFamily,&#10;                                    fontSize = 12.sp,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = Color.White&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun ConversationChatView(&#10;    conversationId: String,&#10;    onBackClick: () -&gt; Unit,&#10;    generatingReplyFor: String?,&#10;    sendingStatus: Map&lt;String, RemoteReplyService.ReplyStatus&gt;,&#10;    sendingMessages: Map&lt;String, String&gt;,&#10;    onGenerateReply: (String) -&gt; Unit,&#10;    onSendReply: (String, String) -&gt; Unit&#10;) {&#10;    val messages = remember(conversationId) {&#10;        NotificationMemoryStore.getMessagesForConversation(conversationId)&#10;    }&#10;&#10;    val conversation = remember(conversationId) {&#10;        NotificationMemoryStore.getAllConversations().find { it.convo_id == conversationId }&#10;    }&#10;&#10;    val platform = remember(conversation) {&#10;        when {&#10;            conversation?.package_name?.contains(&quot;whatsapp&quot;, true) == true -&gt; ChatPlatform.WHATSAPP&#10;            conversation?.package_name?.contains(&quot;instagram&quot;, true) == true -&gt; ChatPlatform.INSTAGRAM&#10;            conversation?.package_name?.contains(&quot;messenger&quot;, true) == true ||&#10;            conversation?.package_name?.contains(&quot;facebook.orca&quot;, true) == true -&gt; ChatPlatform.MESSENGER&#10;            else -&gt; ChatPlatform.GENERAL&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Chat header&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .background(Color(0xFFF8F8F8))&#10;                .padding(12.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            IconButton(&#10;                onClick = onBackClick,&#10;                modifier = Modifier.size(40.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.ArrowBack,&#10;                    contentDescription = &quot;Back to inbox&quot;,&#10;                    tint = Color(0xFF395B64)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(8.dp))&#10;&#10;            // Avatar&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(44.dp)&#10;                    .clip(CircleShape)&#10;                    .background(Color(0xFFA5C9CA)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = conversation?.display_name?.firstOrNull()?.uppercase() ?: &quot;?&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                        fontFamily = AppFonts.KarlaFontFamily,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = Color.White&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(12.dp))&#10;&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = conversation?.display_name ?: &quot;Unknown&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                        fontFamily = AppFonts.KarlaFontFamily,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF395B64)&#10;                    ),&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(platform.color)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(4.dp))&#10;                    Text(&#10;                        text = platform.displayName,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF666666)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        Divider(color = Color(0xFFE0E0E0), thickness = 1.dp)&#10;&#10;        // Messages list&#10;        if (messages.isEmpty()) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(32.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;No messages&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF666666)&#10;                    )&#10;                )&#10;            }&#10;        } else {&#10;            LazyColumn(&#10;                modifier = Modifier.fillMaxSize(),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp),&#10;                contentPadding = PaddingValues(16.dp)&#10;            ) {&#10;                items(messages) { message -&gt;&#10;                    MessageBubble(&#10;                        message = message,&#10;                        isGeneratingReply = generatingReplyFor == message.msg_hash,&#10;                        sendingStatus = sendingStatus[conversationId],&#10;                        sentMessage = sendingMessages[conversationId],&#10;                        onGenerateReply = { onGenerateReply(message.msg_hash) },&#10;                        onSendReply = { editedReply -&gt; onSendReply(conversationId, editedReply) }&#10;                    )&#10;                }&#10;&#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MessageBubble(&#10;    message: NotificationMemoryStore.Message,&#10;    isGeneratingReply: Boolean,&#10;    sendingStatus: RemoteReplyService.ReplyStatus?,&#10;    sentMessage: String?,&#10;    onGenerateReply: () -&gt; Unit,&#10;    onSendReply: (String) -&gt; Unit  // Changed to accept edited reply text&#10;) {&#10;    // State for editable AI reply&#10;    var editableReply by remember(message.ai_reply) { mutableStateOf(message.ai_reply) }&#10;    var isEditing by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        // Original message&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = if (message.is_outgoing) Arrangement.End else Arrangement.Start&#10;        ) {&#10;            Card(&#10;                shape = if (message.is_outgoing) {&#10;                    RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp, bottomEnd = 4.dp, bottomStart = 16.dp)&#10;                } else {&#10;                    RoundedCornerShape(topStart = 4.dp, topEnd = 16.dp, bottomEnd = 16.dp, bottomStart = 16.dp)&#10;                },&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = if (message.is_outgoing) Color(0xFFDCF8C6) else Color(0xFFF0F0F0) // Green for outgoing, gray for incoming&#10;                ),&#10;                modifier = Modifier.widthIn(max = 280.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(12.dp)&#10;                ) {&#10;                    // Only show sender name for incoming messages&#10;                    if (!message.is_outgoing) {&#10;                        Text(&#10;                            text = message.sender_name,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontWeight = FontWeight.Bold,&#10;                                fontSize = 12.sp,&#10;                                color = Color(0xFF395B64)&#10;                            )&#10;                        )&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                    }&#10;                    Text(&#10;                        text = message.msg_content,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF333333)&#10;                        )&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Row(&#10;                        horizontalArrangement = Arrangement.End,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Text(&#10;                            text = SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault()).format(Date(message.timestamp)),&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                fontSize = 11.sp,&#10;                                color = Color(0xFF999999)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // AI Reply if available&#10;        if (message.ai_reply.isNotBlank()) {&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.End&#10;            ) {&#10;                Card(&#10;                    shape = RoundedCornerShape(topStart = 16.dp, topEnd = 16.dp, bottomEnd = 4.dp, bottomStart = 16.dp),&#10;                    colors = CardDefaults.cardColors(containerColor = Color(0xFF1BC994)),&#10;                    modifier = Modifier.widthIn(max = 280.dp)&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(12.dp)&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AutoAwesome,&#10;                                contentDescription = &quot;AI Reply&quot;,&#10;                                modifier = Modifier.size(14.dp),&#10;                                tint = Color.White&#10;                            )&#10;                            Spacer(modifier = Modifier.width(4.dp))&#10;                            Text(&#10;                                text = &quot;AI Reply&quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = AppFonts.KarlaFontFamily,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    fontSize = 11.sp,&#10;                                    color = Color.White&#10;                                )&#10;                            )&#10;&#10;                            if (message.is_sent) {&#10;                                Spacer(modifier = Modifier.width(8.dp))&#10;                                Icon(&#10;                                    imageVector = Icons.Default.CheckCircle,&#10;                                    contentDescription = &quot;Sent&quot;,&#10;                                    modifier = Modifier.size(14.dp),&#10;                                    tint = Color.White&#10;                                )&#10;                            }&#10;                        }&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                        // Show TextField if not sent (editable), otherwise show Text (read-only)&#10;                        if (!message.is_sent) {&#10;                            TextField(&#10;                                value = editableReply,&#10;                                onValueChange = {&#10;                                    editableReply = it&#10;                                    isEditing = true&#10;                                },&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                textStyle = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                    fontSize = 14.sp,&#10;                                    color = Color.White&#10;                                ),&#10;                                colors = TextFieldDefaults.colors(&#10;                                    focusedContainerColor = Color(0xFF1BC994),&#10;                                    unfocusedContainerColor = Color(0xFF1BC994),&#10;                                    disabledContainerColor = Color(0xFF1BC994),&#10;                                    focusedTextColor = Color.White,&#10;                                    unfocusedTextColor = Color.White,&#10;                                    cursorColor = Color.White,&#10;                                    focusedIndicatorColor = Color.White.copy(alpha = 0.5f),&#10;                                    unfocusedIndicatorColor = Color.Transparent&#10;                                ),&#10;                                minLines = 2,&#10;                                maxLines = 6&#10;                            )&#10;                        } else {&#10;                            Text(&#10;                                text = message.ai_reply,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                    fontSize = 14.sp,&#10;                                    color = Color.White&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Action buttons - Only show for INCOMING messages (not outgoing)&#10;        if (!message.is_sent &amp;&amp; !message.is_outgoing) {&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;            Row(&#10;                horizontalArrangement = Arrangement.End,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                if (!message.ai_reply.isNotBlank() &amp;&amp; !isGeneratingReply) {&#10;                    OutlinedButton(&#10;                        onClick = onGenerateReply,&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            contentColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(8.dp),&#10;                        contentPadding = PaddingValues(horizontal = 12.dp, vertical = 6.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.AutoAwesome,&#10;                            contentDescription = &quot;Generate Reply&quot;,&#10;                            modifier = Modifier.size(14.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(4.dp))&#10;                        Text(&#10;                            text = &quot;Generate Reply&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;&#10;                if (isGeneratingReply) {&#10;                    OutlinedButton(&#10;                        onClick = { },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            contentColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(8.dp),&#10;                        contentPadding = PaddingValues(horizontal = 12.dp, vertical = 6.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(14.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color(0xFF395B64)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(4.dp))&#10;                        Text(&#10;                            text = &quot;Generating...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;&#10;                if (message.ai_reply.isNotBlank() &amp;&amp; message.has_reply_action) {&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Button(&#10;                        onClick = { onSendReply(editableReply) },&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF1BC994)&#10;                        ),&#10;                        shape = RoundedCornerShape(8.dp),&#10;                        contentPadding = PaddingValues(horizontal = 12.dp, vertical = 6.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Send,&#10;                            contentDescription = &quot;Send&quot;,&#10;                            modifier = Modifier.size(14.dp),&#10;                            tint = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(4.dp))&#10;                        Text(&#10;                            text = if (isEditing) &quot;Send Edit&quot; else &quot;Send&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnhancedNotificationCard(&#10;    notification: ChatNotification,&#10;    onGenerateReply: () -&gt; Unit,&#10;    onSendReply: () -&gt; Unit,&#10;    onMarkAsRead: (String) -&gt; Unit,&#10;    isGeneratingReply: Boolean,&#10;    sendingStatus: RemoteReplyService.ReplyStatus?,&#10;    sentMessage: String?&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (notification.isRead) Color.White else Color(0xFFF0F8FF)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header with platform and timestamp&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(notification.platform.color)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = notification.platform.displayName,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontSize = 12.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = notification.platform.color&#10;                        )&#10;                    )&#10;&#10;                    // Reply action indicator&#10;                    if (notification.hasReplyAction) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Icon(&#10;                            imageVector = Icons.Default.Reply,&#10;                            contentDescription = &quot;Reply Available&quot;,&#10;                            modifier = Modifier.size(12.dp),&#10;                            tint = Color(0xFF4CAF50)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Text(&#10;                    text = formatTimestamp(notification.timestamp),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF666666)&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Sender and message&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                // Avatar&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(48.dp)&#10;                        .clip(CircleShape)&#10;                        .background(Color(0xFFA5C9CA))&#10;                ) {&#10;                    if (notification.senderAvatar != null) {&#10;                        AsyncImage(&#10;                            model = notification.senderAvatar,&#10;                            contentDescription = &quot;Sender Avatar&quot;,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentScale = ContentScale.Crop&#10;                        )&#10;                    } else {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Person,&#10;                            contentDescription = &quot;Default Avatar&quot;,&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                // Message content&#10;                Column(&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&#10;                        text = notification.senderName,&#10;                        style = MaterialTheme.typography.bodyLarge.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF395B64)&#10;                        )&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                    Text(&#10;                        text = notification.message,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF666666)&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;&#10;                // Unread indicator&#10;                if (!notification.isRead) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(Color(0xFF395B64))&#10;                    )&#10;                }&#10;            }&#10;&#10;            // AI Generated Reply Section&#10;            if (notification.hasGeneratedReply &amp;&amp; notification.generatedReply.isNotBlank()) {&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFFF0F8FF).copy(alpha = 0.7f)&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(12.dp)&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AutoAwesome,&#10;                                contentDescription = &quot;AI Generated&quot;,&#10;                                modifier = Modifier.size(16.dp),&#10;                                tint = Color(0xFF395B64)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                text = &quot;AI Generated Reply&quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = AppFonts.KarlaFontFamily,&#10;                                    fontSize = 12.sp,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = Color(0xFF395B64)&#10;                                )&#10;                            )&#10;&#10;                            // Status indicators&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;&#10;                            when (sendingStatus) {&#10;                                RemoteReplyService.ReplyStatus.SENDING -&gt; {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        strokeWidth = 2.dp,&#10;                                        color = Color(0xFF2196F3)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Sending...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF2196F3)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.RETRYING -&gt; {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        strokeWidth = 2.dp,&#10;                                        color = Color(0xFFFF9800)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Retrying...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFFFF9800)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.SENT -&gt; {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.CheckCircle,&#10;                                        contentDescription = &quot;Sent&quot;,&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        tint = Color(0xFF4CAF50)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Sent&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF4CAF50)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.FAILED -&gt; {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Error,&#10;                                        contentDescription = &quot;Failed&quot;,&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        tint = Color(0xFFE53E3E)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Failed&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFFE53E3E)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                else -&gt; {&#10;                                    if (notification.isSent) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.CheckCircle,&#10;                                            contentDescription = &quot;Sent&quot;,&#10;                                            modifier = Modifier.size(16.dp),&#10;                                            tint = Color(0xFF4CAF50)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = notification.generatedReply,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFF333333)&#10;                            )&#10;                        )&#10;&#10;                        // Show status message if available&#10;                        if (sentMessage != null) {&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                            Text(&#10;                                text = sentMessage,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontSize = 11.sp,&#10;                                    color = when (sendingStatus) {&#10;                                        RemoteReplyService.ReplyStatus.FAILED -&gt; Color(0xFFE53E3E)&#10;                                        RemoteReplyService.ReplyStatus.RETRYING -&gt; Color(0xFFFF9800)&#10;                                        else -&gt; Color(0xFF666666)&#10;                                    }&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Action buttons&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                // Generate Reply Button&#10;                if (!notification.hasGeneratedReply &amp;&amp; !isGeneratingReply) {&#10;                    Button(&#10;                        onClick = onGenerateReply,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.AutoAwesome,&#10;                            contentDescription = &quot;Generate Reply&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Generate Reply&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Loading state for reply generation&#10;                if (isGeneratingReply) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while generating */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF395B64).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Generating...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Regenerate Reply Button (if reply exists and not currently sending)&#10;                if (notification.hasGeneratedReply &amp;&amp;&#10;                    !isGeneratingReply &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.SENDING &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.RETRYING) {&#10;&#10;                    OutlinedButton(&#10;                        onClick = onGenerateReply,&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            contentColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.widthIn(min = 120.dp),&#10;                        contentPadding = PaddingValues(horizontal = 12.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Regenerate&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Regenerate&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 11.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Spacer to push send button to the right&#10;                Spacer(modifier = Modifier.weight(1f))&#10;&#10;                // Send Reply Button (moved to the right side)&#10;                if (notification.hasGeneratedReply &amp;&amp;&#10;                    notification.hasReplyAction &amp;&amp;&#10;                    !notification.isSent &amp;&amp;&#10;                    !isGeneratingReply &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.SENDING &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.RETRYING) {&#10;&#10;                    Button(&#10;                        onClick = onSendReply,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF4CAF50)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Send,&#10;                            contentDescription = &quot;Send Reply&quot;,&#10;                            modifier = Modifier.size(18.dp),&#10;                            tint = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Send&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Sending state button&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.SENDING) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while sending */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF2196F3).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Sending...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Retrying state button&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.RETRYING) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while retrying */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFFF9800).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Retrying...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Retry button for failed sends&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.FAILED) {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                // Retry sending&#10;                                RemoteReplyService.sendReply(&#10;                                    context = context,&#10;                                    conversationId = notification.conversationId,&#10;                                    replyText = notification.generatedReply&#10;                                )&#10;                            }&#10;                        },&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFE53E3E)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Retry&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Retry&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Helper function to format timestamps&#10;@Composable&#10;fun formatTimestamp(timestamp: Long): String {&#10;    val now = System.currentTimeMillis()&#10;    val diff = now - timestamp&#10;&#10;    return when {&#10;        diff &lt; 60 * 1000 -&gt; &quot;now&quot;&#10;        diff &lt; 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 1000)}m ago&quot;&#10;        diff &lt; 24 * 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 60 * 1000)}h ago&quot;&#10;        diff &lt; 48 * 60 * 60 * 1000 -&gt; &quot;yesterday&quot;&#10;        else -&gt; {&#10;            SimpleDateFormat(&quot;MMM dd&quot;, Locale.getDefault()).format(Date(timestamp))&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RawNotificationsContent(&#10;    notifications: List&lt;NotificationMemoryStore.ExternalNotification&gt;&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        if (notifications.isEmpty()) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(32.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Code,&#10;                        contentDescription = &quot;No raw data&quot;,&#10;                        modifier = Modifier.size(48.dp),&#10;                        tint = Color(0xFF666666).copy(alpha = 0.5f)&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;No raw notification data&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF666666)&#10;                        )&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Text(&#10;                        text = &quot;Notifications will appear here in raw format&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF999999)&#10;                        ),&#10;                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            LazyColumn(&#10;                modifier = Modifier.fillMaxSize(),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp),&#10;                contentPadding = PaddingValues(vertical = 8.dp)&#10;            ) {&#10;                items(notifications) { notification -&gt;&#10;                    RawNotificationCard(notification = notification)&#10;                }&#10;&#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RawNotificationCard(&#10;    notification: NotificationMemoryStore.ExternalNotification&#10;) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable { isExpanded = !isExpanded },&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = Color(0xFFF5F5F5)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header with expand/collapse icon&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Code,&#10;                        contentDescription = &quot;Raw Data&quot;,&#10;                        modifier = Modifier.size(16.dp),&#10;                        tint = Color(0xFF1BC994)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = notification.packageName.split(&quot;.&quot;).lastOrNull() ?: notification.packageName,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF1BC994)&#10;                        )&#10;                    )&#10;                }&#10;&#10;                Icon(&#10;                    imageVector = if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,&#10;                    contentDescription = if (isExpanded) &quot;Collapse&quot; else &quot;Expand&quot;,&#10;                    tint = Color(0xFF666666)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Always visible: Hash (for identification)&#10;            RawDataField(label = &quot;Hash&quot;, value = notification.hash.take(16) + &quot;...&quot;)&#10;&#10;            // Expandable content&#10;            if (isExpanded) {&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Show processed fields first&#10;                Text(&#10;                    text = &quot;Processed Fields:&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = AppFonts.KarlaFontFamily,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 13.sp,&#10;                        color = Color(0xFF1BC994)&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                RawDataField(label = &quot;Title&quot;, value = notification.title)&#10;                RawDataField(label = &quot;Text&quot;, value = notification.text)&#10;                RawDataField(label = &quot;Package Name&quot;, value = notification.packageName)&#10;                RawDataField(label = &quot;Timestamp (Formatted)&quot;, value = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date(notification.time)))&#10;                RawDataField(label = &quot;Timestamp (Raw)&quot;, value = notification.time.toString())&#10;                RawDataField(label = &quot;Sender&quot;, value = notification.sender ?: &quot;(null)&quot;)&#10;                RawDataField(label = &quot;Conversation Title&quot;, value = notification.conversationTitle ?: &quot;(null)&quot;)&#10;                RawDataField(label = &quot;Conversation ID&quot;, value = notification.conversationId)&#10;                RawDataField(label = &quot;Has Reply Action&quot;, value = notification.hasReplyAction.toString())&#10;                RawDataField(label = &quot;AI Reply&quot;, value = notification.ai_reply.ifBlank { &quot;(empty)&quot; })&#10;                RawDataField(label = &quot;Is Sent&quot;, value = notification.is_sent.toString())&#10;                RawDataField(label = &quot;Full Hash&quot;, value = notification.hash)&#10;&#10;                // Show ALL raw extras&#10;                if (notification.rawExtras.isNotEmpty()) {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Raw Notification Extras (${notification.rawExtras.size} fields):&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 13.sp,&#10;                            color = Color(0xFFFF6B00)&#10;                        )&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    notification.rawExtras.forEach { (key, value) -&gt;&#10;                        RawDataField(label = key, value = value)&#10;                    }&#10;                }&#10;&#10;                // JSON-like representation&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                val context = LocalContext.current&#10;                val jsonString = remember(notification) {&#10;                    val formattedTime = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())&#10;                        .format(Date(notification.time))&#10;&#10;                    buildString {&#10;                        appendLine(&quot;{&quot;)&#10;                        appendLine(&quot;  \&quot;title\&quot;: \&quot;${notification.title}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;text\&quot;: \&quot;${notification.text}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;packageName\&quot;: \&quot;${notification.packageName}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;timestamp\&quot;: ${notification.time},&quot;)&#10;                        appendLine(&quot;  \&quot;timestamp_formatted\&quot;: \&quot;$formattedTime\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;sender\&quot;: ${if (notification.sender != null) &quot;\&quot;${notification.sender}\&quot;&quot; else &quot;null&quot;},&quot;)&#10;                        appendLine(&quot;  \&quot;conversationTitle\&quot;: ${if (notification.conversationTitle != null) &quot;\&quot;${notification.conversationTitle}\&quot;&quot; else &quot;null&quot;},&quot;)&#10;                        appendLine(&quot;  \&quot;conversationId\&quot;: \&quot;${notification.conversationId}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;hasReplyAction\&quot;: ${notification.hasReplyAction},&quot;)&#10;                        appendLine(&quot;  \&quot;ai_reply\&quot;: \&quot;${notification.ai_reply}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;is_sent\&quot;: ${notification.is_sent},&quot;)&#10;                        appendLine(&quot;  \&quot;hash\&quot;: \&quot;${notification.hash}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;rawExtras\&quot;: {&quot;)&#10;                        notification.rawExtras.entries.forEachIndexed { index, (key, value) -&gt;&#10;                            val isLast = index == notification.rawExtras.size - 1&#10;                            val escapedValue = value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;).replace(&quot;\n&quot;, &quot;\\n&quot;)&#10;                            appendLine(&quot;    \&quot;$key\&quot;: \&quot;$escapedValue\&quot;${if (!isLast) &quot;,&quot; else &quot;&quot;}&quot;)&#10;                        }&#10;                        appendLine(&quot;  }&quot;)&#10;                        append(&quot;}&quot;)&#10;                    }&#10;                }&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Complete JSON Structure:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 13.sp,&#10;                            color = Color(0xFF00FF00)&#10;                        )&#10;                    )&#10;&#10;                    IconButton(&#10;                        onClick = {&#10;                            val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager&#10;                            val clip = ClipData.newPlainText(&quot;Notification JSON&quot;, jsonString)&#10;                            clipboard.setPrimaryClip(clip)&#10;                            Toast.makeText(context, &quot;JSON copied to clipboard!&quot;, Toast.LENGTH_SHORT).show()&#10;                        },&#10;                        modifier = Modifier.size(32.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.ContentCopy,&#10;                            contentDescription = &quot;Copy JSON&quot;,&#10;                            tint = Color(0xFF00FF00),&#10;                            modifier = Modifier.size(18.dp)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Surface(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    shape = RoundedCornerShape(8.dp),&#10;                    color = Color(0xFF2D2D2D)&#10;                ) {&#10;                    Text(&#10;                        text = jsonString,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = Color(0xFF00FF00),&#10;                            lineHeight = 16.sp&#10;                        ),&#10;                        modifier = Modifier.padding(12.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RawDataField(&#10;    label: String,&#10;    value: String&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;    ) {&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = AppFonts.KarlaFontFamily,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 11.sp,&#10;                color = Color(0xFF666666)&#10;            )&#10;        )&#10;        Spacer(modifier = Modifier.height(2.dp))&#10;        Surface(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(4.dp),&#10;            color = Color.White&#10;        ) {&#10;            Text(&#10;                text = value,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF191919)&#10;                ),&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/local.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/local.properties" />
              <option name="originalContent" value="## This file must *NOT* be checked into Version Control Systems,&#10;# as it contains information specific to your local configuration.&#10;#&#10;# Location of the SDK. This is only used by Gradle.&#10;# For customization when using a Version Control System, please read the&#10;# header note.&#10;#Wed Feb 11 18:48:55 NPT 2026&#10;sdk.dir=/Users/biplovgautam/Library/Android/sdk&#10;GROQ_API_KEY=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&#10;" />
              <option name="updatedContent" value="## This file must *NOT* be checked into Version Control Systems,&#10;# as it contains information specific to your local configuration.&#10;#&#10;# Location of the SDK. This is only used by Gradle.&#10;# For customization when using a Version Control System, please read the&#10;# header note.&#10;#Wed Feb 11 18:48:55 NPT 2026&#10;sdk.dir=/Users/biplovgautam/Library/Android/sdk&#10;groq.apiKey=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&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>