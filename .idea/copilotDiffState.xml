<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/RAW_NOTIFICATION_DATA.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/RAW_NOTIFICATION_DATA.md" />
              <option name="updatedContent" value="# Raw Notification Data - Complete Implementation&#10;&#10;## What's Now Truly RAW&#10;&#10;The Raw tab in the Notifications screen now displays **COMPLETELY RAW** notification data without any filtering or processing.&#10;&#10;### Changes Made:&#10;&#10;1. **NotificationMemoryStore.kt**&#10;   - Added `rawExtras: Map&lt;String, String&gt;` field to `ExternalNotification` data class&#10;   - This captures ALL fields from the Android notification extras Bundle&#10;&#10;2. **JawafaiNotificationListenerService.kt**&#10;   - Modified `extractNotificationData()` to capture ALL extras from the notification Bundle&#10;   - Every single key-value pair from `notification.extras.keySet()` is now stored&#10;   - Handles different data types (CharSequence, Array, etc.)&#10;&#10;3. **NotificationScreen.kt (Raw Tab)**&#10;   - Displays two sections:&#10;     - **Processed Fields**: The structured data we extract (title, text, sender, etc.)&#10;     - **Raw Notification Extras**: ALL the raw fields from the Android notification Bundle&#10;   - Shows a count of how many raw extras fields were captured&#10;   - Includes complete JSON structure with all raw extras&#10;&#10;### What You'll See in the Raw Tab:&#10;&#10;#### Processed Fields (Our structured data):&#10;- Title&#10;- Text&#10;- Package Name&#10;- Timestamp&#10;- Sender&#10;- Conversation Title&#10;- Conversation ID&#10;- Has Reply Action&#10;- AI Reply&#10;- Is Sent&#10;- Full Hash&#10;&#10;#### Raw Notification Extras (EVERYTHING from Android):&#10;This section shows ALL fields that Android includes in the notification, which may include:&#10;- `android.title`&#10;- `android.text`&#10;- `android.subText`&#10;- `android.conversationTitle`&#10;- `android.largeIcon`&#10;- `android.messages` (for messaging notifications)&#10;- `android.person` (for person info)&#10;- `android.remoteInputHistory`&#10;- `android.showWhen`&#10;- `android.showChronometer`&#10;- `android.messagingUser`&#10;- And many more app-specific fields...&#10;&#10;### Why This Is Important:&#10;&#10;Different messaging apps (WhatsApp, Instagram, Messenger) may include different custom fields in their notifications. By capturing ALL raw extras, you can:&#10;&#10;1. **Analyze patterns** - See what fields different apps use&#10;2. **Find hidden data** - Discover fields we're not currently using&#10;3. **Debug issues** - See exactly what Android is giving us&#10;4. **Improve extraction** - Identify better ways to extract sender names, message content, etc.&#10;&#10;### JSON Structure:&#10;&#10;The Raw tab now shows a complete JSON representation including:&#10;```json&#10;{&#10;  &quot;title&quot;: &quot;...&quot;,&#10;  &quot;text&quot;: &quot;...&quot;,&#10;  &quot;packageName&quot;: &quot;...&quot;,&#10;  &quot;rawExtras&quot;: {&#10;    &quot;android.title&quot;: &quot;...&quot;,&#10;    &quot;android.text&quot;: &quot;...&quot;,&#10;    &quot;android.subText&quot;: &quot;...&quot;,&#10;    &quot;android.conversationTitle&quot;: &quot;...&quot;,&#10;    ...all other fields...&#10;  }&#10;}&#10;```&#10;&#10;## Usage:&#10;&#10;1. Navigate to **Notifications** screen&#10;2. Switch to the **Raw** tab&#10;3. Tap on any notification card to expand it&#10;4. Scroll through the **Raw Notification Extras** section to see ALL fields&#10;5. Compare different apps to see pattern differences&#10;&#10;This is now **COMPLETELY RAW** - nothing is filtered or left out!&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/service/JawafaiNotificationListenerService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/service/JawafaiNotificationListenerService.kt" />
              <option name="originalContent" value="package com.example.jawafai.service&#10;&#10;import android.service.notification.NotificationListenerService&#10;import android.service.notification.StatusBarNotification&#10;import android.content.Intent&#10;import android.content.BroadcastReceiver&#10;import android.content.IntentFilter&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager&#10;import android.content.Context&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.app.RemoteInput&#10;import android.app.Notification&#10;import android.app.PendingIntent&#10;import android.os.Bundle&#10;import kotlin.random.Random&#10;&#10;class JawafaiNotificationListenerService : NotificationListenerService() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;JawafaiNotifService&quot;&#10;        const val NOTIFICATION_BROADCAST_ACTION = &quot;com.example.jawafai.NOTIFICATION_LISTENER_EVENT&quot;&#10;        const val AI_REPLY_BROADCAST_ACTION = &quot;com.example.jawafai.AI_REPLY_REQUEST&quot;&#10;        const val REPLY_GENERATED_ACTION = &quot;com.example.jawafai.REPLY_GENERATED&quot;&#10;        const val REPLY_SENT_ACTION = &quot;com.example.jawafai.REPLY_SENT&quot;&#10;&#10;        // Define the package names of apps we want to capture notifications from&#10;        private val SUPPORTED_APPS = mapOf(&#10;            &quot;com.instagram.android&quot; to &quot;Instagram&quot;,&#10;            &quot;com.whatsapp&quot; to &quot;WhatsApp&quot;,&#10;            &quot;com.facebook.orca&quot; to &quot;Facebook Messenger&quot;,&#10;            &quot;com.whatsapp.w4b&quot; to &quot;WhatsApp Business&quot;,&#10;            &quot;com.facebook.katana&quot; to &quot;Facebook&quot;,&#10;            &quot;com.snapchat.android&quot; to &quot;Snapchat&quot;,&#10;            &quot;com.twitter.android&quot; to &quot;Twitter&quot;,&#10;            &quot;com.telegram.messenger&quot; to &quot;Telegram&quot;&#10;        )&#10;&#10;        // Utility to check if notification access is enabled&#10;        fun isNotificationAccessEnabled(context: Context): Boolean {&#10;            val enabledListeners = Settings.Secure.getString(&#10;                context.contentResolver,&#10;                &quot;enabled_notification_listeners&quot;&#10;            ) ?: return false&#10;            return enabledListeners.contains(context.packageName)&#10;        }&#10;    }&#10;&#10;    private val localBroadcastManager by lazy { LocalBroadcastManager.getInstance(this) }&#10;&#10;    // Broadcast receiver for handling AI-generated replies&#10;    private val replyReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                REPLY_GENERATED_ACTION -&gt; handleGeneratedReply(intent)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onListenerConnected() {&#10;        super.onListenerConnected()&#10;        Log.d(TAG, &quot;Smart Messaging Assistant connected!&quot;)&#10;&#10;        // Register broadcast receiver for AI replies&#10;        val filter = IntentFilter(REPLY_GENERATED_ACTION)&#10;        localBroadcastManager.registerReceiver(replyReceiver, filter)&#10;    }&#10;&#10;    override fun onListenerDisconnected() {&#10;        super.onListenerDisconnected()&#10;        Log.d(TAG, &quot;Smart Messaging Assistant disconnected!&quot;)&#10;&#10;        // Unregister broadcast receiver&#10;        try {&#10;            localBroadcastManager.unregisterReceiver(replyReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error unregistering receiver: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun isSupportedApp(packageName: String): Boolean {&#10;        return SUPPORTED_APPS.containsKey(packageName)&#10;    }&#10;&#10;    override fun onNotificationPosted(sbn: StatusBarNotification) {&#10;        val packageName = sbn.packageName ?: return&#10;&#10;        // Skip our own notifications and unsupported apps&#10;        if (packageName == this.packageName || !isSupportedApp(packageName)) {&#10;            Log.d(TAG, &quot;Notification ignored - not from supported app: $packageName&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(TAG, &quot;Processing notification from ${SUPPORTED_APPS[packageName]}&quot;)&#10;&#10;        try {&#10;            val smartNotification = extractNotificationData(sbn)&#10;&#10;            // Store notification with deduplication&#10;            val isNewNotification = NotificationMemoryStore.addNotification(smartNotification)&#10;&#10;            if (isNewNotification) {&#10;                Log.d(TAG, &quot;New notification stored: ${smartNotification.conversationId}&quot;)&#10;&#10;                // Broadcast to AI module if reply action is available&#10;                if (smartNotification.hasReplyAction) {&#10;                    triggerAIReplyGeneration(smartNotification)&#10;                }&#10;            } else {&#10;                Log.d(TAG, &quot;Duplicate notification ignored&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error processing notification: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract comprehensive notification data for smart messaging&#10;     */&#10;    private fun extractNotificationData(sbn: StatusBarNotification): NotificationMemoryStore.ExternalNotification {&#10;        val notification = sbn.notification&#10;        val extras = notification.extras&#10;        val packageName = sbn.packageName&#10;&#10;        // Extract basic notification fields&#10;        val title = extras.getString(Notification.EXTRA_TITLE) ?: &quot;(No Title)&quot;&#10;        val text = extras.getCharSequence(Notification.EXTRA_TEXT)?.toString() ?: &quot;(No Text)&quot;&#10;        val sender = extras.getString(Notification.EXTRA_SUB_TEXT)&#10;        val conversationTitle = extras.getString(Notification.EXTRA_CONVERSATION_TITLE)&#10;        val timestamp = sbn.postTime&#10;&#10;        // Generate conversation ID - use notification key or create custom one&#10;        val conversationId = generateConversationId(sbn, title, sender)&#10;&#10;        // Check for reply action and RemoteInput&#10;        val (hasReplyAction, replyAction, remoteInput) = extractReplyAction(notification)&#10;&#10;        // Generate hash for deduplication&#10;        val hash = NotificationMemoryStore.generateHash(title, text, packageName)&#10;&#10;        Log.d(TAG, &quot;Extracted notification data:&quot;)&#10;        Log.d(TAG, &quot;  Title: $title&quot;)&#10;        Log.d(TAG, &quot;  Text: $text&quot;)&#10;        Log.d(TAG, &quot;  Sender: $sender&quot;)&#10;        Log.d(TAG, &quot;  ConversationId: $conversationId&quot;)&#10;        Log.d(TAG, &quot;  HasReplyAction: $hasReplyAction&quot;)&#10;&#10;        return NotificationMemoryStore.ExternalNotification(&#10;            title = title,&#10;            text = text,&#10;            packageName = packageName,&#10;            time = timestamp,&#10;            sender = sender,&#10;            conversationTitle = conversationTitle,&#10;            conversationId = conversationId,&#10;            hasReplyAction = hasReplyAction,&#10;            replyAction = replyAction,&#10;            remoteInput = remoteInput,&#10;            hash = hash&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Generate unique conversation ID&#10;     */&#10;    private fun generateConversationId(sbn: StatusBarNotification, title: String, sender: String?): String {&#10;        // Try to use notification key first&#10;        val notificationKey = sbn.key&#10;        if (notificationKey.isNotBlank()) {&#10;            return &quot;${sbn.packageName}_${notificationKey.hashCode()}&quot;&#10;        }&#10;&#10;        // Fallback to combination of package, title, and sender&#10;        val identifier = &quot;${sbn.packageName}_${title}_${sender ?: &quot;unknown&quot;}&quot;&#10;        return identifier.hashCode().toString()&#10;    }&#10;&#10;    /**&#10;     * Extract reply action and RemoteInput from notification&#10;     */&#10;    private fun extractReplyAction(notification: Notification): Triple&lt;Boolean, Notification.Action?, RemoteInput?&gt; {&#10;        val actions = notification.actions ?: return Triple(false, null, null)&#10;&#10;        for (action in actions) {&#10;            val remoteInputs = action.remoteInputs&#10;            if (remoteInputs != null &amp;&amp; remoteInputs.isNotEmpty()) {&#10;                // Found reply action with RemoteInput&#10;                Log.d(TAG, &quot;Reply action found: ${action.title}&quot;)&#10;                return Triple(true, action, remoteInputs[0])&#10;            }&#10;        }&#10;&#10;        return Triple(false, null, null)&#10;    }&#10;&#10;    /**&#10;     * Trigger AI reply generation via broadcast&#10;     */&#10;    private fun triggerAIReplyGeneration(notification: NotificationMemoryStore.ExternalNotification) {&#10;        Log.d(TAG, &quot;Triggering AI reply generation for: ${notification.conversationId}&quot;)&#10;&#10;        val intent = Intent(AI_REPLY_BROADCAST_ACTION).apply {&#10;            putExtra(&quot;conversationId&quot;, notification.conversationId)&#10;            putExtra(&quot;title&quot;, notification.title)&#10;            putExtra(&quot;text&quot;, notification.text)&#10;            putExtra(&quot;sender&quot;, notification.sender)&#10;            putExtra(&quot;packageName&quot;, notification.packageName)&#10;            putExtra(&quot;timestamp&quot;, notification.time)&#10;        }&#10;&#10;        LocalBroadcastManager.getInstance(this).sendBroadcast(intent)&#10;    }&#10;&#10;    /**&#10;     * Send smart reply using RemoteInput&#10;     */&#10;    fun sendSmartReply(sbn: StatusBarNotification, replyText: String): Boolean {&#10;        try {&#10;            val notification = sbn.notification&#10;            val actions = notification.actions ?: return false&#10;&#10;            // Find reply action&#10;            var replyAction: Notification.Action? = null&#10;            var remoteInput: RemoteInput? = null&#10;&#10;            for (action in actions) {&#10;                val remoteInputs = action.remoteInputs&#10;                if (remoteInputs != null &amp;&amp; remoteInputs.isNotEmpty()) {&#10;                    replyAction = action&#10;                    remoteInput = remoteInputs[0]&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (replyAction == null || remoteInput == null) {&#10;                Log.e(TAG, &quot;No reply action found for notification&quot;)&#10;                return false&#10;            }&#10;&#10;            // Create reply intent&#10;            val replyIntent = Intent()&#10;            val bundle = Bundle()&#10;            bundle.putCharSequence(remoteInput.resultKey, replyText)&#10;            RemoteInput.addResultsToIntent(arrayOf(remoteInput), replyIntent, bundle)&#10;&#10;            // Send reply&#10;            replyAction.actionIntent.send(this, 0, replyIntent)&#10;&#10;            Log.d(TAG, &quot;Smart reply sent: $replyText&quot;)&#10;            return true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending smart reply: ${e.message}&quot;, e)&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send smart reply by conversation ID&#10;     */&#10;    fun sendSmartReplyByConversationId(conversationId: String, replyText: String): Boolean {&#10;        val notifications = NotificationMemoryStore.getNotificationsByConversation(conversationId)&#10;        val latestNotificationWithReply = notifications.firstOrNull { it.hasReplyAction }&#10;&#10;        if (latestNotificationWithReply?.replyAction != null &amp;&amp; latestNotificationWithReply.remoteInput != null) {&#10;            try {&#10;                val replyIntent = Intent()&#10;                val bundle = Bundle()&#10;                bundle.putCharSequence(latestNotificationWithReply.remoteInput.resultKey, replyText)&#10;                RemoteInput.addResultsToIntent(arrayOf(latestNotificationWithReply.remoteInput), replyIntent, bundle)&#10;&#10;                latestNotificationWithReply.replyAction.actionIntent.send(this, 0, replyIntent)&#10;&#10;                Log.d(TAG, &quot;Smart reply sent via conversation ID: $replyText&quot;)&#10;                return true&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error sending smart reply via conversation ID: ${e.message}&quot;, e)&#10;                return false&#10;            }&#10;        }&#10;&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Handle AI-generated reply and attempt to send it&#10;     */&#10;    private fun handleGeneratedReply(intent: Intent) {&#10;        val conversationId = intent.getStringExtra(&quot;conversationId&quot;) ?: return&#10;        val replyText = intent.getStringExtra(&quot;replyText&quot;) ?: return&#10;        val packageName = intent.getStringExtra(&quot;packageName&quot;) ?: return&#10;        val notificationHash = intent.getStringExtra(&quot;notificationHash&quot;) ?: return&#10;&#10;        Log.d(TAG, &quot; Received AI-generated reply for conversation: $conversationId&quot;)&#10;        Log.d(TAG, &quot; Reply: ${replyText.take(100)}...&quot;)&#10;&#10;        // Attempt to send the reply&#10;        val success = sendSmartReplyByConversationId(conversationId, replyText)&#10;&#10;        // Update notification status&#10;        if (success) {&#10;            NotificationMemoryStore.markAsSent(notificationHash)&#10;            Log.d(TAG, &quot;✅ Reply sent successfully&quot;)&#10;        } else {&#10;            Log.e(TAG, &quot;❌ Failed to send reply&quot;)&#10;        }&#10;&#10;        // Broadcast reply sent status&#10;        val statusIntent = Intent(REPLY_SENT_ACTION).apply {&#10;            putExtra(&quot;conversationId&quot;, conversationId)&#10;            putExtra(&quot;notificationHash&quot;, notificationHash)&#10;            putExtra(&quot;success&quot;, success)&#10;            putExtra(&quot;replyText&quot;, replyText)&#10;        }&#10;        localBroadcastManager.sendBroadcast(statusIntent)&#10;    }&#10;&#10;    override fun onNotificationRemoved(sbn: StatusBarNotification) {&#10;        val packageName = sbn.packageName ?: return&#10;        if (isSupportedApp(packageName)) {&#10;            Log.d(TAG, &quot;Notification removed from ${SUPPORTED_APPS[packageName]}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.jawafai.service&#10;&#10;import android.service.notification.NotificationListenerService&#10;import android.service.notification.StatusBarNotification&#10;import android.content.Intent&#10;import android.content.BroadcastReceiver&#10;import android.content.IntentFilter&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager&#10;import android.content.Context&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.os.Build&#10;import androidx.core.app.NotificationCompat&#10;import android.provider.Settings&#10;import android.util.Log&#10;import android.app.RemoteInput&#10;import android.app.Notification&#10;import android.app.PendingIntent&#10;import android.os.Bundle&#10;import kotlin.random.Random&#10;&#10;class JawafaiNotificationListenerService : NotificationListenerService() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;JawafaiNotifService&quot;&#10;        const val NOTIFICATION_BROADCAST_ACTION = &quot;com.example.jawafai.NOTIFICATION_LISTENER_EVENT&quot;&#10;        const val AI_REPLY_BROADCAST_ACTION = &quot;com.example.jawafai.AI_REPLY_REQUEST&quot;&#10;        const val REPLY_GENERATED_ACTION = &quot;com.example.jawafai.REPLY_GENERATED&quot;&#10;        const val REPLY_SENT_ACTION = &quot;com.example.jawafai.REPLY_SENT&quot;&#10;&#10;        // Define the package names of apps we want to capture notifications from&#10;        private val SUPPORTED_APPS = mapOf(&#10;            &quot;com.instagram.android&quot; to &quot;Instagram&quot;,&#10;            &quot;com.whatsapp&quot; to &quot;WhatsApp&quot;,&#10;            &quot;com.facebook.orca&quot; to &quot;Facebook Messenger&quot;,&#10;            &quot;com.whatsapp.w4b&quot; to &quot;WhatsApp Business&quot;,&#10;            &quot;com.facebook.katana&quot; to &quot;Facebook&quot;,&#10;            &quot;com.snapchat.android&quot; to &quot;Snapchat&quot;,&#10;            &quot;com.twitter.android&quot; to &quot;Twitter&quot;,&#10;            &quot;com.telegram.messenger&quot; to &quot;Telegram&quot;&#10;        )&#10;&#10;        // Utility to check if notification access is enabled&#10;        fun isNotificationAccessEnabled(context: Context): Boolean {&#10;            val enabledListeners = Settings.Secure.getString(&#10;                context.contentResolver,&#10;                &quot;enabled_notification_listeners&quot;&#10;            ) ?: return false&#10;            return enabledListeners.contains(context.packageName)&#10;        }&#10;    }&#10;&#10;    private val localBroadcastManager by lazy { LocalBroadcastManager.getInstance(this) }&#10;&#10;    // Broadcast receiver for handling AI-generated replies&#10;    private val replyReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                REPLY_GENERATED_ACTION -&gt; handleGeneratedReply(intent)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onListenerConnected() {&#10;        super.onListenerConnected()&#10;        Log.d(TAG, &quot;Smart Messaging Assistant connected!&quot;)&#10;&#10;        // Register broadcast receiver for AI replies&#10;        val filter = IntentFilter(REPLY_GENERATED_ACTION)&#10;        localBroadcastManager.registerReceiver(replyReceiver, filter)&#10;    }&#10;&#10;    override fun onListenerDisconnected() {&#10;        super.onListenerDisconnected()&#10;        Log.d(TAG, &quot;Smart Messaging Assistant disconnected!&quot;)&#10;&#10;        // Unregister broadcast receiver&#10;        try {&#10;            localBroadcastManager.unregisterReceiver(replyReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error unregistering receiver: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun isSupportedApp(packageName: String): Boolean {&#10;        return SUPPORTED_APPS.containsKey(packageName)&#10;    }&#10;&#10;    override fun onNotificationPosted(sbn: StatusBarNotification) {&#10;        val packageName = sbn.packageName ?: return&#10;&#10;        // Skip our own notifications and unsupported apps&#10;        if (packageName == this.packageName || !isSupportedApp(packageName)) {&#10;            Log.d(TAG, &quot;Notification ignored - not from supported app: $packageName&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(TAG, &quot;Processing notification from ${SUPPORTED_APPS[packageName]}&quot;)&#10;&#10;        try {&#10;            val smartNotification = extractNotificationData(sbn)&#10;&#10;            // Store notification with deduplication&#10;            val isNewNotification = NotificationMemoryStore.addNotification(smartNotification)&#10;&#10;            if (isNewNotification) {&#10;                Log.d(TAG, &quot;New notification stored: ${smartNotification.conversationId}&quot;)&#10;&#10;                // Broadcast to AI module if reply action is available&#10;                if (smartNotification.hasReplyAction) {&#10;                    triggerAIReplyGeneration(smartNotification)&#10;                }&#10;            } else {&#10;                Log.d(TAG, &quot;Duplicate notification ignored&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error processing notification: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extract comprehensive notification data for smart messaging&#10;     */&#10;    private fun extractNotificationData(sbn: StatusBarNotification): NotificationMemoryStore.ExternalNotification {&#10;        val notification = sbn.notification&#10;        val extras = notification.extras&#10;        val packageName = sbn.packageName&#10;&#10;        // Extract basic notification fields&#10;        val title = extras.getString(Notification.EXTRA_TITLE) ?: &quot;(No Title)&quot;&#10;        val text = extras.getCharSequence(Notification.EXTRA_TEXT)?.toString() ?: &quot;(No Text)&quot;&#10;        val sender = extras.getString(Notification.EXTRA_SUB_TEXT)&#10;        val conversationTitle = extras.getString(Notification.EXTRA_CONVERSATION_TITLE)&#10;        val timestamp = sbn.postTime&#10;&#10;        // Generate conversation ID - use notification key or create custom one&#10;        val conversationId = generateConversationId(sbn, title, sender)&#10;&#10;        // Check for reply action and RemoteInput&#10;        val (hasReplyAction, replyAction, remoteInput) = extractReplyAction(notification)&#10;&#10;        // Generate hash for deduplication&#10;        val hash = NotificationMemoryStore.generateHash(title, text, packageName)&#10;        &#10;        // Capture ALL raw extras for debugging/analysis&#10;        val rawExtras = mutableMapOf&lt;String, String&gt;()&#10;        extras.keySet()?.forEach { key -&gt;&#10;            val value = extras.get(key)&#10;            rawExtras[key] = when (value) {&#10;                is CharSequence -&gt; value.toString()&#10;                is Array&lt;*&gt; -&gt; value.joinToString(&quot;, &quot;) { it.toString() }&#10;                else -&gt; value.toString()&#10;            }&#10;        }&#10;&#10;        Log.d(TAG, &quot;Extracted notification data:&quot;)&#10;        Log.d(TAG, &quot;  Title: $title&quot;)&#10;        Log.d(TAG, &quot;  Text: $text&quot;)&#10;        Log.d(TAG, &quot;  Sender: $sender&quot;)&#10;        Log.d(TAG, &quot;  ConversationId: $conversationId&quot;)&#10;        Log.d(TAG, &quot;  HasReplyAction: $hasReplyAction&quot;)&#10;        Log.d(TAG, &quot;  Raw Extras Count: ${rawExtras.size}&quot;)&#10;&#10;        return NotificationMemoryStore.ExternalNotification(&#10;            title = title,&#10;            text = text,&#10;            packageName = packageName,&#10;            time = timestamp,&#10;            sender = sender,&#10;            conversationTitle = conversationTitle,&#10;            conversationId = conversationId,&#10;            hasReplyAction = hasReplyAction,&#10;            replyAction = replyAction,&#10;            remoteInput = remoteInput,&#10;            hash = hash,&#10;            rawExtras = rawExtras&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Generate unique conversation ID&#10;     */&#10;    private fun generateConversationId(sbn: StatusBarNotification, title: String, sender: String?): String {&#10;        // Try to use notification key first&#10;        val notificationKey = sbn.key&#10;        if (notificationKey.isNotBlank()) {&#10;            return &quot;${sbn.packageName}_${notificationKey.hashCode()}&quot;&#10;        }&#10;&#10;        // Fallback to combination of package, title, and sender&#10;        val identifier = &quot;${sbn.packageName}_${title}_${sender ?: &quot;unknown&quot;}&quot;&#10;        return identifier.hashCode().toString()&#10;    }&#10;&#10;    /**&#10;     * Extract reply action and RemoteInput from notification&#10;     */&#10;    private fun extractReplyAction(notification: Notification): Triple&lt;Boolean, Notification.Action?, RemoteInput?&gt; {&#10;        val actions = notification.actions ?: return Triple(false, null, null)&#10;&#10;        for (action in actions) {&#10;            val remoteInputs = action.remoteInputs&#10;            if (remoteInputs != null &amp;&amp; remoteInputs.isNotEmpty()) {&#10;                // Found reply action with RemoteInput&#10;                Log.d(TAG, &quot;Reply action found: ${action.title}&quot;)&#10;                return Triple(true, action, remoteInputs[0])&#10;            }&#10;        }&#10;&#10;        return Triple(false, null, null)&#10;    }&#10;&#10;    /**&#10;     * Trigger AI reply generation via broadcast&#10;     */&#10;    private fun triggerAIReplyGeneration(notification: NotificationMemoryStore.ExternalNotification) {&#10;        Log.d(TAG, &quot;Triggering AI reply generation for: ${notification.conversationId}&quot;)&#10;&#10;        val intent = Intent(AI_REPLY_BROADCAST_ACTION).apply {&#10;            putExtra(&quot;conversationId&quot;, notification.conversationId)&#10;            putExtra(&quot;title&quot;, notification.title)&#10;            putExtra(&quot;text&quot;, notification.text)&#10;            putExtra(&quot;sender&quot;, notification.sender)&#10;            putExtra(&quot;packageName&quot;, notification.packageName)&#10;            putExtra(&quot;timestamp&quot;, notification.time)&#10;        }&#10;&#10;        LocalBroadcastManager.getInstance(this).sendBroadcast(intent)&#10;    }&#10;&#10;    /**&#10;     * Send smart reply using RemoteInput&#10;     */&#10;    fun sendSmartReply(sbn: StatusBarNotification, replyText: String): Boolean {&#10;        try {&#10;            val notification = sbn.notification&#10;            val actions = notification.actions ?: return false&#10;&#10;            // Find reply action&#10;            var replyAction: Notification.Action? = null&#10;            var remoteInput: RemoteInput? = null&#10;&#10;            for (action in actions) {&#10;                val remoteInputs = action.remoteInputs&#10;                if (remoteInputs != null &amp;&amp; remoteInputs.isNotEmpty()) {&#10;                    replyAction = action&#10;                    remoteInput = remoteInputs[0]&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (replyAction == null || remoteInput == null) {&#10;                Log.e(TAG, &quot;No reply action found for notification&quot;)&#10;                return false&#10;            }&#10;&#10;            // Create reply intent&#10;            val replyIntent = Intent()&#10;            val bundle = Bundle()&#10;            bundle.putCharSequence(remoteInput.resultKey, replyText)&#10;            RemoteInput.addResultsToIntent(arrayOf(remoteInput), replyIntent, bundle)&#10;&#10;            // Send reply&#10;            replyAction.actionIntent.send(this, 0, replyIntent)&#10;&#10;            Log.d(TAG, &quot;Smart reply sent: $replyText&quot;)&#10;            return true&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error sending smart reply: ${e.message}&quot;, e)&#10;            return false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Send smart reply by conversation ID&#10;     */&#10;    fun sendSmartReplyByConversationId(conversationId: String, replyText: String): Boolean {&#10;        val notifications = NotificationMemoryStore.getNotificationsByConversation(conversationId)&#10;        val latestNotificationWithReply = notifications.firstOrNull { it.hasReplyAction }&#10;&#10;        if (latestNotificationWithReply?.replyAction != null &amp;&amp; latestNotificationWithReply.remoteInput != null) {&#10;            try {&#10;                val replyIntent = Intent()&#10;                val bundle = Bundle()&#10;                bundle.putCharSequence(latestNotificationWithReply.remoteInput.resultKey, replyText)&#10;                RemoteInput.addResultsToIntent(arrayOf(latestNotificationWithReply.remoteInput), replyIntent, bundle)&#10;&#10;                latestNotificationWithReply.replyAction.actionIntent.send(this, 0, replyIntent)&#10;&#10;                Log.d(TAG, &quot;Smart reply sent via conversation ID: $replyText&quot;)&#10;                return true&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error sending smart reply via conversation ID: ${e.message}&quot;, e)&#10;                return false&#10;            }&#10;        }&#10;&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Handle AI-generated reply and attempt to send it&#10;     */&#10;    private fun handleGeneratedReply(intent: Intent) {&#10;        val conversationId = intent.getStringExtra(&quot;conversationId&quot;) ?: return&#10;        val replyText = intent.getStringExtra(&quot;replyText&quot;) ?: return&#10;        val packageName = intent.getStringExtra(&quot;packageName&quot;) ?: return&#10;        val notificationHash = intent.getStringExtra(&quot;notificationHash&quot;) ?: return&#10;&#10;        Log.d(TAG, &quot; Received AI-generated reply for conversation: $conversationId&quot;)&#10;        Log.d(TAG, &quot; Reply: ${replyText.take(100)}...&quot;)&#10;&#10;        // Attempt to send the reply&#10;        val success = sendSmartReplyByConversationId(conversationId, replyText)&#10;&#10;        // Update notification status&#10;        if (success) {&#10;            NotificationMemoryStore.markAsSent(notificationHash)&#10;            Log.d(TAG, &quot;✅ Reply sent successfully&quot;)&#10;        } else {&#10;            Log.e(TAG, &quot;❌ Failed to send reply&quot;)&#10;        }&#10;&#10;        // Broadcast reply sent status&#10;        val statusIntent = Intent(REPLY_SENT_ACTION).apply {&#10;            putExtra(&quot;conversationId&quot;, conversationId)&#10;            putExtra(&quot;notificationHash&quot;, notificationHash)&#10;            putExtra(&quot;success&quot;, success)&#10;            putExtra(&quot;replyText&quot;, replyText)&#10;        }&#10;        localBroadcastManager.sendBroadcast(statusIntent)&#10;    }&#10;&#10;    override fun onNotificationRemoved(sbn: StatusBarNotification) {&#10;        val packageName = sbn.packageName ?: return&#10;        if (isSupportedApp(packageName)) {&#10;            Log.d(TAG, &quot;Notification removed from ${SUPPORTED_APPS[packageName]}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/service/NotificationMemoryStore.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/service/NotificationMemoryStore.kt" />
              <option name="originalContent" value="package com.example.jawafai.service&#10;&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.snapshots.SnapshotStateList&#10;import android.app.RemoteInput&#10;import android.app.Notification&#10;import java.security.MessageDigest&#10;&#10;// Enhanced in-memory notification store for smart messaging assistant&#10;object NotificationMemoryStore {&#10;    data class ExternalNotification(&#10;        val title: String,                    // Group name or sender&#10;        val text: String,                     // Message content&#10;        val packageName: String,              // App package name&#10;        val time: Long,                       // Timestamp&#10;        val sender: String? = null,           // android.subText - actual sender&#10;        val conversationTitle: String? = null, // For group chats&#10;        val conversationId: String,           // Unique conversation identifier&#10;        val hasReplyAction: Boolean = false,  // Whether reply action is available&#10;        val replyAction: Notification.Action? = null, // Reply action reference&#10;        val remoteInput: RemoteInput? = null, // RemoteInput reference&#10;        val hash: String,                     // For deduplication&#10;        val ai_reply: String = &quot;&quot;,            // AI generated reply (empty if not generated)&#10;        val is_sent: Boolean = false          // Whether reply was sent via RemoteInput&#10;    )&#10;&#10;    private val notifications: SnapshotStateList&lt;ExternalNotification&gt; = mutableStateListOf()&#10;    private val notificationHashes: MutableSet&lt;String&gt; = mutableSetOf()&#10;&#10;    /**&#10;     * Add notification with deduplication&#10;     */&#10;    fun addNotification(notification: ExternalNotification): Boolean {&#10;        return if (!notificationHashes.contains(notification.hash)) {&#10;            notifications.add(0, notification) // Add to top&#10;            notificationHashes.add(notification.hash)&#10;&#10;            // Limit store size to prevent memory issues&#10;            if (notifications.size &gt; 500) {&#10;                val removed = notifications.removeAt(notifications.size - 1)&#10;                notificationHashes.remove(removed.hash)&#10;            }&#10;            true&#10;        } else {&#10;            false // Duplicate notification&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all notifications&#10;     */&#10;    fun getAllNotifications(): List&lt;ExternalNotification&gt; = notifications.toList()&#10;&#10;    /**&#10;     * Get notifications by package name&#10;     */&#10;    fun getNotificationsByPackage(packageName: String): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.packageName == packageName }&#10;    }&#10;&#10;    /**&#10;     * Get notifications by conversation ID&#10;     */&#10;    fun getNotificationsByConversation(conversationId: String): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.conversationId == conversationId }&#10;    }&#10;&#10;    /**&#10;     * Get notifications with reply actions&#10;     */&#10;    fun getNotificationsWithReplyActions(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.hasReplyAction }&#10;    }&#10;&#10;    /**&#10;     * Clear all notifications&#10;     */&#10;    fun clear() {&#10;        notifications.clear()&#10;        notificationHashes.clear()&#10;    }&#10;&#10;    /**&#10;     * Generate hash for deduplication&#10;     */&#10;    fun generateHash(title: String, text: String, packageName: String): String {&#10;        val input = &quot;$title|$text|$packageName&quot;&#10;        val digest = MessageDigest.getInstance(&quot;MD5&quot;)&#10;        val hashBytes = digest.digest(input.toByteArray())&#10;        return hashBytes.joinToString(&quot;&quot;) { &quot;%02x&quot;.format(it) }&#10;    }&#10;&#10;    /**&#10;     * Get conversation context for AI processing&#10;     */&#10;    fun getConversationContext(conversationId: String, limit: Int = 10): List&lt;ExternalNotification&gt; {&#10;        return notifications&#10;            .filter { it.conversationId == conversationId }&#10;            .take(limit)&#10;            .reversed() // Chronological order for context&#10;    }&#10;&#10;    /**&#10;     * Update AI reply for a notification&#10;     */&#10;    fun updateAIReply(hash: String, aiReply: String): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(ai_reply = aiReply)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Mark notification as sent&#10;     */&#10;    fun markAsSent(hash: String): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(is_sent = true)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Update both AI reply and sent status&#10;     */&#10;    fun updateReplyAndSentStatus(hash: String, aiReply: String, isSent: Boolean): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(ai_reply = aiReply, is_sent = isSent)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Get notifications with AI replies&#10;     */&#10;    fun getNotificationsWithAIReplies(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.ai_reply.isNotBlank() }&#10;    }&#10;&#10;    /**&#10;     * Get unsent notifications with AI replies&#10;     */&#10;    fun getUnsentAIReplies(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.ai_reply.isNotBlank() &amp;&amp; !it.is_sent }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.jawafai.service&#10;&#10;import androidx.compose.runtime.mutableStateListOf&#10;import androidx.compose.runtime.snapshots.SnapshotStateList&#10;import android.app.RemoteInput&#10;import android.app.Notification&#10;import java.security.MessageDigest&#10;&#10;// Enhanced in-memory notification store for smart messaging assistant&#10;object NotificationMemoryStore {&#10;    data class ExternalNotification(&#10;        val title: String,                    // Group name or sender&#10;        val text: String,                     // Message content&#10;        val packageName: String,              // App package name&#10;        val time: Long,                       // Timestamp&#10;        val sender: String? = null,           // android.subText - actual sender&#10;        val conversationTitle: String? = null, // For group chats&#10;        val conversationId: String,           // Unique conversation identifier&#10;        val hasReplyAction: Boolean = false,  // Whether reply action is available&#10;        val replyAction: Notification.Action? = null, // Reply action reference&#10;        val remoteInput: RemoteInput? = null, // RemoteInput reference&#10;        val hash: String,                     // For deduplication&#10;        val ai_reply: String = &quot;&quot;,            // AI generated reply (empty if not generated)&#10;        val is_sent: Boolean = false,         // Whether reply was sent via RemoteInput&#10;        val rawExtras: Map&lt;String, String&gt; = emptyMap() // ALL raw notification extras for debugging&#10;    )&#10;&#10;    private val notifications: SnapshotStateList&lt;ExternalNotification&gt; = mutableStateListOf()&#10;    private val notificationHashes: MutableSet&lt;String&gt; = mutableSetOf()&#10;&#10;    /**&#10;     * Add notification with deduplication&#10;     */&#10;    fun addNotification(notification: ExternalNotification): Boolean {&#10;        return if (!notificationHashes.contains(notification.hash)) {&#10;            notifications.add(0, notification) // Add to top&#10;            notificationHashes.add(notification.hash)&#10;&#10;            // Limit store size to prevent memory issues&#10;            if (notifications.size &gt; 500) {&#10;                val removed = notifications.removeAt(notifications.size - 1)&#10;                notificationHashes.remove(removed.hash)&#10;            }&#10;            true&#10;        } else {&#10;            false // Duplicate notification&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Get all notifications&#10;     */&#10;    fun getAllNotifications(): List&lt;ExternalNotification&gt; = notifications.toList()&#10;&#10;    /**&#10;     * Get notifications by package name&#10;     */&#10;    fun getNotificationsByPackage(packageName: String): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.packageName == packageName }&#10;    }&#10;&#10;    /**&#10;     * Get notifications by conversation ID&#10;     */&#10;    fun getNotificationsByConversation(conversationId: String): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.conversationId == conversationId }&#10;    }&#10;&#10;    /**&#10;     * Get notifications with reply actions&#10;     */&#10;    fun getNotificationsWithReplyActions(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.hasReplyAction }&#10;    }&#10;&#10;    /**&#10;     * Clear all notifications&#10;     */&#10;    fun clear() {&#10;        notifications.clear()&#10;        notificationHashes.clear()&#10;    }&#10;&#10;    /**&#10;     * Generate hash for deduplication&#10;     */&#10;    fun generateHash(title: String, text: String, packageName: String): String {&#10;        val input = &quot;$title|$text|$packageName&quot;&#10;        val digest = MessageDigest.getInstance(&quot;MD5&quot;)&#10;        val hashBytes = digest.digest(input.toByteArray())&#10;        return hashBytes.joinToString(&quot;&quot;) { &quot;%02x&quot;.format(it) }&#10;    }&#10;&#10;    /**&#10;     * Get conversation context for AI processing&#10;     */&#10;    fun getConversationContext(conversationId: String, limit: Int = 10): List&lt;ExternalNotification&gt; {&#10;        return notifications&#10;            .filter { it.conversationId == conversationId }&#10;            .take(limit)&#10;            .reversed() // Chronological order for context&#10;    }&#10;&#10;    /**&#10;     * Update AI reply for a notification&#10;     */&#10;    fun updateAIReply(hash: String, aiReply: String): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(ai_reply = aiReply)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Mark notification as sent&#10;     */&#10;    fun markAsSent(hash: String): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(is_sent = true)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Update both AI reply and sent status&#10;     */&#10;    fun updateReplyAndSentStatus(hash: String, aiReply: String, isSent: Boolean): Boolean {&#10;        val index = notifications.indexOfFirst { it.hash == hash }&#10;        if (index != -1) {&#10;            val notification = notifications[index]&#10;            notifications[index] = notification.copy(ai_reply = aiReply, is_sent = isSent)&#10;            return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Get notifications with AI replies&#10;     */&#10;    fun getNotificationsWithAIReplies(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.ai_reply.isNotBlank() }&#10;    }&#10;&#10;    /**&#10;     * Get unsent notifications with AI replies&#10;     */&#10;    fun getUnsentAIReplies(): List&lt;ExternalNotification&gt; {&#10;        return notifications.filter { it.ai_reply.isNotBlank() &amp;&amp; !it.is_sent }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/view/dashboard/notifications/NotificationScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/jawafai/view/dashboard/notifications/NotificationScreen.kt" />
              <option name="originalContent" value="package com.example.jawafai.view.dashboard.notifications&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.OnBackPressedCallback&#10;import androidx.activity.compose.LocalOnBackPressedDispatcherOwner&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager&#10;import coil.compose.AsyncImage&#10;import com.example.jawafai.R&#10;import com.example.jawafai.managers.GroqApiManager&#10;import com.example.jawafai.service.NotificationMemoryStore&#10;import com.example.jawafai.service.NotificationAIReplyManager&#10;import com.example.jawafai.service.SmartReplyAIModule&#10;import com.example.jawafai.service.RemoteReplyService&#10;import com.example.jawafai.ui.theme.AppFonts&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;// Data classes for chat notifications&#10;data class ChatNotification(&#10;    val id: String,&#10;    val platform: ChatPlatform,&#10;    val senderName: String,&#10;    val senderAvatar: String?,&#10;    val message: String,&#10;    val timestamp: Long,&#10;    val isRead: Boolean,&#10;    val hasGeneratedReply: Boolean = false,&#10;    val generatedReply: String = &quot;&quot;,&#10;    val hasReplyAction: Boolean = false,&#10;    val isSent: Boolean = false,&#10;    val conversationId: String = &quot;&quot;,&#10;    val notificationHash: String = &quot;&quot;&#10;)&#10;&#10;enum class ChatPlatform(&#10;    val displayName: String,&#10;    val color: Color,&#10;    val iconRes: Int? = null&#10;) {&#10;    WHATSAPP(&quot;WhatsApp&quot;, Color(0xFF25D366)),&#10;    INSTAGRAM(&quot;Instagram&quot;, Color(0xFFE4405F)),&#10;    MESSENGER(&quot;Messenger&quot;, Color(0xFF0084FF)),&#10;    GENERAL(&quot;General&quot;, Color(0xFF395B64))&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun NotificationScreen(&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val backDispatcher = LocalOnBackPressedDispatcherOwner.current?.onBackPressedDispatcher&#10;&#10;    // State management&#10;    var isRefreshing by remember { mutableStateOf(false) }&#10;    var selectedFilter by remember { mutableStateOf&lt;ChatPlatform?&gt;(null) }&#10;    var generatingReplyFor by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Send status tracking&#10;    var sendingStatus by remember { mutableStateOf&lt;Map&lt;String, RemoteReplyService.ReplyStatus&gt;&gt;(emptyMap()) }&#10;    var sendingMessages by remember { mutableStateOf&lt;Map&lt;String, String&gt;&gt;(emptyMap()) }&#10;&#10;    // Broadcast receiver for reply status updates&#10;    val replyStatusReceiver = remember {&#10;        object : BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                when (intent?.action) {&#10;                    &quot;com.example.jawafai.REPLY_STATUS&quot; -&gt; {&#10;                        val conversationId = intent.getStringExtra(&quot;conversationId&quot;) ?: return&#10;                        val status = intent.getStringExtra(&quot;status&quot;) ?: return&#10;                        val message = intent.getStringExtra(&quot;message&quot;)&#10;&#10;                        sendingStatus = sendingStatus.toMutableMap().apply {&#10;                            this[conversationId] = RemoteReplyService.ReplyStatus.valueOf(status)&#10;                        }&#10;&#10;                        if (message != null) {&#10;                            sendingMessages = sendingMessages.toMutableMap().apply {&#10;                                this[conversationId] = message&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Register broadcast receiver&#10;    LaunchedEffect(Unit) {&#10;        val filter = IntentFilter(&quot;com.example.jawafai.REPLY_STATUS&quot;)&#10;        LocalBroadcastManager.getInstance(context).registerReceiver(replyStatusReceiver, filter)&#10;    }&#10;&#10;    // Cleanup receiver&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            try {&#10;                LocalBroadcastManager.getInstance(context).unregisterReceiver(replyStatusReceiver)&#10;            } catch (e: Exception) {&#10;                // Receiver might already be unregistered&#10;            }&#10;        }&#10;    }&#10;&#10;    // Observe external notifications from NotificationMemoryStore&#10;    val externalNotifications by remember {&#10;        derivedStateOf {&#10;            NotificationMemoryStore.getAllNotifications()&#10;        }&#10;    }&#10;&#10;    // Map external notifications to ChatNotification for display&#10;    val liveNotifications = remember(externalNotifications) {&#10;        externalNotifications.map { notification -&gt;&#10;            ChatNotification(&#10;                id = notification.hash,&#10;                platform = when {&#10;                    notification.packageName.contains(&quot;whatsapp&quot;, true) -&gt; ChatPlatform.WHATSAPP&#10;                    notification.packageName.contains(&quot;instagram&quot;, true) -&gt; ChatPlatform.INSTAGRAM&#10;                    notification.packageName.contains(&quot;messenger&quot;, true) ||&#10;                    notification.packageName.contains(&quot;facebook.orca&quot;, true) -&gt; ChatPlatform.MESSENGER&#10;                    else -&gt; ChatPlatform.GENERAL&#10;                },&#10;                senderName = notification.sender?.takeIf { it.isNotBlank() } ?: notification.title.ifBlank { notification.packageName },&#10;                senderAvatar = null,&#10;                message = notification.text,&#10;                timestamp = notification.time,&#10;                isRead = false,&#10;                hasGeneratedReply = notification.ai_reply.isNotBlank(),&#10;                generatedReply = notification.ai_reply,&#10;                hasReplyAction = notification.hasReplyAction,&#10;                isSent = notification.is_sent,&#10;                conversationId = notification.conversationId,&#10;                notificationHash = notification.hash&#10;            )&#10;        }&#10;    }&#10;&#10;    // Filter notifications based on search and platform filter&#10;    val filteredNotifications = remember(selectedFilter, liveNotifications) {&#10;        liveNotifications.filter { notification -&gt;&#10;            val matchesFilter = selectedFilter?.let { filter -&gt;&#10;                notification.platform == filter&#10;            } ?: true&#10;&#10;            matchesFilter&#10;        }&#10;    }&#10;&#10;    // Function to generate AI reply with enhanced debugging&#10;    fun generateAIReply(notificationHash: String) {&#10;        coroutineScope.launch {&#10;            try {&#10;                Log.d(&quot;NotificationScreen&quot;, &quot; Starting AI reply generation for hash: $notificationHash&quot;)&#10;                generatingReplyFor = notificationHash&#10;&#10;                // Get the notification from memory store&#10;                val notification = NotificationMemoryStore.getAllNotifications()&#10;                    .find { it.hash == notificationHash }&#10;&#10;                if (notification == null) {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ Notification not found in memory store&quot;)&#10;                    Toast.makeText(context, &quot;Error: Notification not found&quot;, Toast.LENGTH_SHORT).show()&#10;                    return@launch&#10;                }&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot;✅ Found notification: ${notification.text}&quot;)&#10;&#10;                // Check if API key is configured&#10;                if (!GroqApiManager.isApiKeyConfigured()) {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ Groq API key not configured&quot;)&#10;                    Toast.makeText(context, &quot;Error: API key not configured. Please check your settings.&quot;, Toast.LENGTH_LONG).show()&#10;                    return@launch&#10;                }&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot;✅ API key configured, generating reply...&quot;)&#10;                Toast.makeText(context, &quot;Generating AI reply...&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                // Generate AI reply&#10;                val result = NotificationAIReplyManager.generateAIReply(&#10;                    notification = notification,&#10;                    userPersona = null, // You can pass user persona here&#10;                    context = context&#10;                )&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot; AI reply result: success=${result.success}, error=${result.error}&quot;)&#10;&#10;                if (result.success &amp;&amp; result.reply != null) {&#10;                    Log.d(&quot;NotificationScreen&quot;, &quot;✅ AI reply generated successfully: ${result.reply.take(100)}...&quot;)&#10;                    Toast.makeText(context, &quot;AI reply generated successfully! &quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ AI reply generation failed: ${result.error}&quot;)&#10;                    val errorMessage = when {&#10;                        result.error?.contains(&quot;API key not configured&quot;) == true -&gt;&#10;                            &quot;Please configure your Groq API key in settings&quot;&#10;                        result.error?.contains(&quot;401&quot;) == true -&gt;&#10;                            &quot;Invalid API key. Please check your configuration.&quot;&#10;                        result.error?.contains(&quot;429&quot;) == true -&gt;&#10;                            &quot;Rate limit exceeded. Please try again later.&quot;&#10;                        result.error?.contains(&quot;network&quot;) == true -&gt;&#10;                            &quot;Network error. Please check your connection.&quot;&#10;                        result.error?.contains(&quot;timeout&quot;) == true -&gt;&#10;                            &quot;Request timeout. Please try again.&quot;&#10;                        else -&gt;&#10;                            &quot;Failed to generate reply: ${result.error ?: &quot;Unknown error&quot;}&quot;&#10;                    }&#10;                    Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;NotificationScreen&quot;, &quot;❌ Exception in AI reply generation: ${e.message}&quot;, e)&#10;                Toast.makeText(context, &quot;Error generating reply: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            } finally {&#10;                generatingReplyFor = null&#10;            }&#10;        }&#10;    }&#10;&#10;    // Enhanced function to send reply with status tracking&#10;    fun sendReply(conversationId: String, replyText: String) {&#10;        coroutineScope.launch {&#10;            try {&#10;                // Use RemoteReplyService to send the reply with retry mechanism&#10;                val result = RemoteReplyService.sendReply(&#10;                    context = context,&#10;                    conversationId = conversationId,&#10;                    replyText = replyText&#10;                )&#10;&#10;                if (result.success) {&#10;                    Toast.makeText(context, &quot;Reply sent successfully! &quot;, Toast.LENGTH_SHORT).show()&#10;                    // Clear any error messages&#10;                    sendingMessages = sendingMessages.toMutableMap().apply {&#10;                        remove(conversationId)&#10;                    }&#10;                } else {&#10;                    val errorMessage = when {&#10;                        result.error?.contains(&quot;No notification with reply action&quot;) == true -&gt;&#10;                            &quot;Cannot send reply: This notification doesn't support direct replies.&quot;&#10;                        result.canRetry -&gt;&#10;                            &quot;Failed to send reply after ${RemoteReplyService.MAX_RETRY_ATTEMPTS} attempts: ${result.error}&quot;&#10;                        else -&gt;&#10;                            &quot;Failed to send reply: ${result.error}&quot;&#10;                    }&#10;                    Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(context, &quot;Error sending reply: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Manual retry function&#10;    fun retryReply(conversationId: String, replyText: String) {&#10;        // Clear previous status&#10;        RemoteReplyService.clearSendingStatus(conversationId)&#10;        sendingStatus = sendingStatus.toMutableMap().apply {&#10;            remove(conversationId)&#10;        }&#10;        sendingMessages = sendingMessages.toMutableMap().apply {&#10;            remove(conversationId)&#10;        }&#10;&#10;        // Retry sending&#10;        sendReply(conversationId, replyText)&#10;    }&#10;&#10;    // Pull to refresh simulation&#10;    LaunchedEffect(isRefreshing) {&#10;        if (isRefreshing) {&#10;            delay(1000) // Simulate refresh&#10;            isRefreshing = false&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White),&#10;        containerColor = Color.White,&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Smart Notifications&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 24.sp,&#10;                            color = Color(0xFF395B64)&#10;                        )&#10;                    )&#10;                },&#10;                actions = {&#10;                    IconButton(&#10;                        onClick = {&#10;                            // Clear notification memory store&#10;                            NotificationMemoryStore.clear()&#10;                            Toast.makeText(context, &quot;Notifications cleared&quot;, Toast.LENGTH_SHORT).show()&#10;                            isRefreshing = true&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.Refresh,&#10;                            contentDescription = &quot;Clear notifications&quot;,&#10;                            tint = Color(0xFF395B64)&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(Color.White)&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Platform Filter Chips&#10;            LazyRow(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                contentPadding = PaddingValues(vertical = 8.dp)&#10;            ) {&#10;                item {&#10;                    FilterChip(&#10;                        onClick = { selectedFilter = null },&#10;                        label = { Text(&quot;All&quot;) },&#10;                        selected = selectedFilter == null,&#10;                        colors = FilterChipDefaults.filterChipColors(&#10;                            selectedContainerColor = Color(0xFF395B64),&#10;                            selectedLabelColor = Color.White&#10;                        )&#10;                    )&#10;                }&#10;&#10;                items(ChatPlatform.values().toList()) { platform -&gt;&#10;                    FilterChip(&#10;                        onClick = {&#10;                            selectedFilter = if (selectedFilter == platform) null else platform&#10;                        },&#10;                        label = { Text(platform.displayName) },&#10;                        selected = selectedFilter == platform,&#10;                        colors = FilterChipDefaults.filterChipColors(&#10;                            selectedContainerColor = platform.color,&#10;                            selectedLabelColor = Color.White&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Loading indicator&#10;            AnimatedVisibility(visible = isRefreshing) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 16.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        color = Color(0xFF395B64),&#10;                        modifier = Modifier.size(32.dp),&#10;                        strokeWidth = 3.dp&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Notifications List&#10;            if (filteredNotifications.isEmpty()) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Notifications,&#10;                            contentDescription = &quot;No notifications&quot;,&#10;                            modifier = Modifier.size(48.dp),&#10;                            tint = Color(0xFF666666).copy(alpha = 0.5f)&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        Text(&#10;                            text = &quot;No notifications yet&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF666666)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    items(filteredNotifications) { notification -&gt;&#10;                        EnhancedNotificationCard(&#10;                            notification = notification,&#10;                            onGenerateReply = { generateAIReply(notification.notificationHash) },&#10;                            onSendReply = { sendReply(notification.conversationId, notification.generatedReply) },&#10;                            onMarkAsRead = { /* Handle mark as read */ },&#10;                            isGeneratingReply = generatingReplyFor == notification.notificationHash,&#10;                            sendingStatus = sendingStatus[notification.conversationId],&#10;                            sentMessage = sendingMessages[notification.conversationId]&#10;                        )&#10;                    }&#10;&#10;                    item {&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnhancedNotificationCard(&#10;    notification: ChatNotification,&#10;    onGenerateReply: () -&gt; Unit,&#10;    onSendReply: () -&gt; Unit,&#10;    onMarkAsRead: (String) -&gt; Unit,&#10;    isGeneratingReply: Boolean,&#10;    sendingStatus: RemoteReplyService.ReplyStatus?,&#10;    sentMessage: String?&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (notification.isRead) Color.White else Color(0xFFF0F8FF)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header with platform and timestamp&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(notification.platform.color)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = notification.platform.displayName,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontSize = 12.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = notification.platform.color&#10;                        )&#10;                    )&#10;&#10;                    // Reply action indicator&#10;                    if (notification.hasReplyAction) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Icon(&#10;                            imageVector = Icons.Default.Reply,&#10;                            contentDescription = &quot;Reply Available&quot;,&#10;                            modifier = Modifier.size(12.dp),&#10;                            tint = Color(0xFF4CAF50)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Text(&#10;                    text = formatTimestamp(notification.timestamp),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF666666)&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Sender and message&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                // Avatar&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(48.dp)&#10;                        .clip(CircleShape)&#10;                        .background(Color(0xFFA5C9CA))&#10;                ) {&#10;                    if (notification.senderAvatar != null) {&#10;                        AsyncImage(&#10;                            model = notification.senderAvatar,&#10;                            contentDescription = &quot;Sender Avatar&quot;,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentScale = ContentScale.Crop&#10;                        )&#10;                    } else {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Person,&#10;                            contentDescription = &quot;Default Avatar&quot;,&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                // Message content&#10;                Column(&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&#10;                        text = notification.senderName,&#10;                        style = MaterialTheme.typography.bodyLarge.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF395B64)&#10;                        )&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                    Text(&#10;                        text = notification.message,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF666666)&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;&#10;                // Unread indicator&#10;                if (!notification.isRead) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(Color(0xFF395B64))&#10;                    )&#10;                }&#10;            }&#10;&#10;            // AI Generated Reply Section&#10;            if (notification.hasGeneratedReply &amp;&amp; notification.generatedReply.isNotBlank()) {&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFFF0F8FF).copy(alpha = 0.7f)&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(12.dp)&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AutoAwesome,&#10;                                contentDescription = &quot;AI Generated&quot;,&#10;                                modifier = Modifier.size(16.dp),&#10;                                tint = Color(0xFF395B64)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                text = &quot;AI Generated Reply&quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = AppFonts.KarlaFontFamily,&#10;                                    fontSize = 12.sp,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = Color(0xFF395B64)&#10;                                )&#10;                            )&#10;&#10;                            // Status indicators&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;&#10;                            when (sendingStatus) {&#10;                                RemoteReplyService.ReplyStatus.SENDING -&gt; {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        strokeWidth = 2.dp,&#10;                                        color = Color(0xFF2196F3)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Sending...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF2196F3)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.RETRYING -&gt; {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        strokeWidth = 2.dp,&#10;                                        color = Color(0xFFFF9800)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Retrying...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFFFF9800)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.SENT -&gt; {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.CheckCircle,&#10;                                        contentDescription = &quot;Sent&quot;,&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        tint = Color(0xFF4CAF50)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Sent&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF4CAF50)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.FAILED -&gt; {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Error,&#10;                                        contentDescription = &quot;Failed&quot;,&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        tint = Color(0xFFE53E3E)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Failed&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFFE53E3E)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                else -&gt; {&#10;                                    if (notification.isSent) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.CheckCircle,&#10;                                            contentDescription = &quot;Sent&quot;,&#10;                                            modifier = Modifier.size(16.dp),&#10;                                            tint = Color(0xFF4CAF50)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = notification.generatedReply,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFF333333)&#10;                            )&#10;                        )&#10;&#10;                        // Show status message if available&#10;                        if (sentMessage != null) {&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                            Text(&#10;                                text = sentMessage,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontSize = 11.sp,&#10;                                    color = when (sendingStatus) {&#10;                                        RemoteReplyService.ReplyStatus.FAILED -&gt; Color(0xFFE53E3E)&#10;                                        RemoteReplyService.ReplyStatus.RETRYING -&gt; Color(0xFFFF9800)&#10;                                        else -&gt; Color(0xFF666666)&#10;                                    }&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Action buttons&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                // Generate Reply Button&#10;                if (!notification.hasGeneratedReply &amp;&amp; !isGeneratingReply) {&#10;                    Button(&#10;                        onClick = onGenerateReply,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.AutoAwesome,&#10;                            contentDescription = &quot;Generate Reply&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Generate Reply&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Loading state for reply generation&#10;                if (isGeneratingReply) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while generating */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF395B64).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Generating...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Regenerate Reply Button (if reply exists and not currently sending)&#10;                if (notification.hasGeneratedReply &amp;&amp;&#10;                    !isGeneratingReply &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.SENDING &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.RETRYING) {&#10;&#10;                    OutlinedButton(&#10;                        onClick = onGenerateReply,&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            contentColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.widthIn(min = 120.dp),&#10;                        contentPadding = PaddingValues(horizontal = 12.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Regenerate&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Regenerate&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 11.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Spacer to push send button to the right&#10;                Spacer(modifier = Modifier.weight(1f))&#10;&#10;                // Send Reply Button (moved to the right side)&#10;                if (notification.hasGeneratedReply &amp;&amp;&#10;                    notification.hasReplyAction &amp;&amp;&#10;                    !notification.isSent &amp;&amp;&#10;                    !isGeneratingReply &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.SENDING &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.RETRYING) {&#10;&#10;                    Button(&#10;                        onClick = onSendReply,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF4CAF50)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Send,&#10;                            contentDescription = &quot;Send Reply&quot;,&#10;                            modifier = Modifier.size(18.dp),&#10;                            tint = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Send&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Sending state button&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.SENDING) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while sending */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF2196F3).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Sending...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Retrying state button&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.RETRYING) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while retrying */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFFF9800).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Retrying...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Retry button for failed sends&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.FAILED) {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                // Retry sending&#10;                                RemoteReplyService.sendReply(&#10;                                    context = context,&#10;                                    conversationId = notification.conversationId,&#10;                                    replyText = notification.generatedReply&#10;                                )&#10;                            }&#10;                        },&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFE53E3E)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Retry&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Retry&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Helper function to format timestamps&#10;@Composable&#10;fun formatTimestamp(timestamp: Long): String {&#10;    val now = System.currentTimeMillis()&#10;    val diff = now - timestamp&#10;&#10;    return when {&#10;        diff &lt; 60 * 1000 -&gt; &quot;now&quot;&#10;        diff &lt; 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 1000)}m ago&quot;&#10;        diff &lt; 24 * 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 60 * 1000)}h ago&quot;&#10;        diff &lt; 48 * 60 * 60 * 1000 -&gt; &quot;yesterday&quot;&#10;        else -&gt; {&#10;            SimpleDateFormat(&quot;MMM dd&quot;, Locale.getDefault()).format(Date(timestamp))&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.jawafai.view.dashboard.notifications&#10;&#10;import android.content.BroadcastReceiver&#10;import android.content.ClipData&#10;import android.content.ClipboardManager&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.util.Log&#10;import android.widget.Toast&#10;import androidx.activity.OnBackPressedCallback&#10;import androidx.activity.compose.LocalOnBackPressedDispatcherOwner&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.shape.CircleShape&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.material3.TabRowDefaults.tabIndicatorOffset&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.focus.FocusRequester&#10;import androidx.compose.ui.focus.focusRequester&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.localbroadcastmanager.content.LocalBroadcastManager&#10;import coil.compose.AsyncImage&#10;import com.example.jawafai.R&#10;import com.example.jawafai.managers.GroqApiManager&#10;import com.example.jawafai.service.NotificationMemoryStore&#10;import com.example.jawafai.service.NotificationAIReplyManager&#10;import com.example.jawafai.service.SmartReplyAIModule&#10;import com.example.jawafai.service.RemoteReplyService&#10;import com.example.jawafai.ui.theme.AppFonts&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;// Data classes for chat notifications&#10;data class ChatNotification(&#10;    val id: String,&#10;    val platform: ChatPlatform,&#10;    val senderName: String,&#10;    val senderAvatar: String?,&#10;    val message: String,&#10;    val timestamp: Long,&#10;    val isRead: Boolean,&#10;    val hasGeneratedReply: Boolean = false,&#10;    val generatedReply: String = &quot;&quot;,&#10;    val hasReplyAction: Boolean = false,&#10;    val isSent: Boolean = false,&#10;    val conversationId: String = &quot;&quot;,&#10;    val notificationHash: String = &quot;&quot;&#10;)&#10;&#10;enum class ChatPlatform(&#10;    val displayName: String,&#10;    val color: Color,&#10;    val iconRes: Int? = null&#10;) {&#10;    WHATSAPP(&quot;WhatsApp&quot;, Color(0xFF25D366)),&#10;    INSTAGRAM(&quot;Instagram&quot;, Color(0xFFE4405F)),&#10;    MESSENGER(&quot;Messenger&quot;, Color(0xFF0084FF)),&#10;    GENERAL(&quot;General&quot;, Color(0xFF395B64))&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun NotificationScreen(&#10;    onNavigateBack: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val backDispatcher = LocalOnBackPressedDispatcherOwner.current?.onBackPressedDispatcher&#10;&#10;    // State management&#10;    var isRefreshing by remember { mutableStateOf(false) }&#10;    var selectedFilter by remember { mutableStateOf&lt;ChatPlatform?&gt;(null) }&#10;    var generatingReplyFor by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var selectedTab by remember { mutableStateOf(0) } // 0 = Smart, 1 = Raw&#10;&#10;    // Send status tracking&#10;    var sendingStatus by remember { mutableStateOf&lt;Map&lt;String, RemoteReplyService.ReplyStatus&gt;&gt;(emptyMap()) }&#10;    var sendingMessages by remember { mutableStateOf&lt;Map&lt;String, String&gt;&gt;(emptyMap()) }&#10;&#10;    // Broadcast receiver for reply status updates&#10;    val replyStatusReceiver = remember {&#10;        object : BroadcastReceiver() {&#10;            override fun onReceive(context: Context?, intent: Intent?) {&#10;                when (intent?.action) {&#10;                    &quot;com.example.jawafai.REPLY_STATUS&quot; -&gt; {&#10;                        val conversationId = intent.getStringExtra(&quot;conversationId&quot;) ?: return&#10;                        val status = intent.getStringExtra(&quot;status&quot;) ?: return&#10;                        val message = intent.getStringExtra(&quot;message&quot;)&#10;&#10;                        sendingStatus = sendingStatus.toMutableMap().apply {&#10;                            this[conversationId] = RemoteReplyService.ReplyStatus.valueOf(status)&#10;                        }&#10;&#10;                        if (message != null) {&#10;                            sendingMessages = sendingMessages.toMutableMap().apply {&#10;                                this[conversationId] = message&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Register broadcast receiver&#10;    LaunchedEffect(Unit) {&#10;        val filter = IntentFilter(&quot;com.example.jawafai.REPLY_STATUS&quot;)&#10;        LocalBroadcastManager.getInstance(context).registerReceiver(replyStatusReceiver, filter)&#10;    }&#10;&#10;    // Cleanup receiver&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            try {&#10;                LocalBroadcastManager.getInstance(context).unregisterReceiver(replyStatusReceiver)&#10;            } catch (e: Exception) {&#10;                // Receiver might already be unregistered&#10;            }&#10;        }&#10;    }&#10;&#10;    // Observe external notifications from NotificationMemoryStore&#10;    val externalNotifications by remember {&#10;        derivedStateOf {&#10;            NotificationMemoryStore.getAllNotifications()&#10;        }&#10;    }&#10;&#10;    // Map external notifications to ChatNotification for display&#10;    val liveNotifications = remember(externalNotifications) {&#10;        externalNotifications.map { notification -&gt;&#10;            ChatNotification(&#10;                id = notification.hash,&#10;                platform = when {&#10;                    notification.packageName.contains(&quot;whatsapp&quot;, true) -&gt; ChatPlatform.WHATSAPP&#10;                    notification.packageName.contains(&quot;instagram&quot;, true) -&gt; ChatPlatform.INSTAGRAM&#10;                    notification.packageName.contains(&quot;messenger&quot;, true) ||&#10;                    notification.packageName.contains(&quot;facebook.orca&quot;, true) -&gt; ChatPlatform.MESSENGER&#10;                    else -&gt; ChatPlatform.GENERAL&#10;                },&#10;                senderName = notification.sender?.takeIf { it.isNotBlank() } ?: notification.title.ifBlank { notification.packageName },&#10;                senderAvatar = null,&#10;                message = notification.text,&#10;                timestamp = notification.time,&#10;                isRead = false,&#10;                hasGeneratedReply = notification.ai_reply.isNotBlank(),&#10;                generatedReply = notification.ai_reply,&#10;                hasReplyAction = notification.hasReplyAction,&#10;                isSent = notification.is_sent,&#10;                conversationId = notification.conversationId,&#10;                notificationHash = notification.hash&#10;            )&#10;        }&#10;    }&#10;&#10;    // Filter notifications based on search and platform filter&#10;    val filteredNotifications = remember(selectedFilter, liveNotifications) {&#10;        liveNotifications.filter { notification -&gt;&#10;            val matchesFilter = selectedFilter?.let { filter -&gt;&#10;                notification.platform == filter&#10;            } ?: true&#10;&#10;            matchesFilter&#10;        }&#10;    }&#10;&#10;    // Function to generate AI reply with enhanced debugging&#10;    fun generateAIReply(notificationHash: String) {&#10;        coroutineScope.launch {&#10;            try {&#10;                Log.d(&quot;NotificationScreen&quot;, &quot; Starting AI reply generation for hash: $notificationHash&quot;)&#10;                generatingReplyFor = notificationHash&#10;&#10;                // Get the notification from memory store&#10;                val notification = NotificationMemoryStore.getAllNotifications()&#10;                    .find { it.hash == notificationHash }&#10;&#10;                if (notification == null) {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ Notification not found in memory store&quot;)&#10;                    Toast.makeText(context, &quot;Error: Notification not found&quot;, Toast.LENGTH_SHORT).show()&#10;                    return@launch&#10;                }&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot;✅ Found notification: ${notification.text}&quot;)&#10;&#10;                // Check if API key is configured&#10;                if (!GroqApiManager.isApiKeyConfigured()) {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ Groq API key not configured&quot;)&#10;                    Toast.makeText(context, &quot;Error: API key not configured. Please check your settings.&quot;, Toast.LENGTH_LONG).show()&#10;                    return@launch&#10;                }&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot;✅ API key configured, generating reply...&quot;)&#10;                Toast.makeText(context, &quot;Generating AI reply...&quot;, Toast.LENGTH_SHORT).show()&#10;&#10;                // Generate AI reply&#10;                val result = NotificationAIReplyManager.generateAIReply(&#10;                    notification = notification,&#10;                    userPersona = null, // You can pass user persona here&#10;                    context = context&#10;                )&#10;&#10;                Log.d(&quot;NotificationScreen&quot;, &quot; AI reply result: success=${result.success}, error=${result.error}&quot;)&#10;&#10;                if (result.success &amp;&amp; result.reply != null) {&#10;                    Log.d(&quot;NotificationScreen&quot;, &quot;✅ AI reply generated successfully: ${result.reply.take(100)}...&quot;)&#10;                    Toast.makeText(context, &quot;AI reply generated successfully! &quot;, Toast.LENGTH_SHORT).show()&#10;                } else {&#10;                    Log.e(&quot;NotificationScreen&quot;, &quot;❌ AI reply generation failed: ${result.error}&quot;)&#10;                    val errorMessage = when {&#10;                        result.error?.contains(&quot;API key not configured&quot;) == true -&gt;&#10;                            &quot;Please configure your Groq API key in settings&quot;&#10;                        result.error?.contains(&quot;401&quot;) == true -&gt;&#10;                            &quot;Invalid API key. Please check your configuration.&quot;&#10;                        result.error?.contains(&quot;429&quot;) == true -&gt;&#10;                            &quot;Rate limit exceeded. Please try again later.&quot;&#10;                        result.error?.contains(&quot;network&quot;) == true -&gt;&#10;                            &quot;Network error. Please check your connection.&quot;&#10;                        result.error?.contains(&quot;timeout&quot;) == true -&gt;&#10;                            &quot;Request timeout. Please try again.&quot;&#10;                        else -&gt;&#10;                            &quot;Failed to generate reply: ${result.error ?: &quot;Unknown error&quot;}&quot;&#10;                    }&#10;                    Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;NotificationScreen&quot;, &quot;❌ Exception in AI reply generation: ${e.message}&quot;, e)&#10;                Toast.makeText(context, &quot;Error generating reply: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;            } finally {&#10;                generatingReplyFor = null&#10;            }&#10;        }&#10;    }&#10;&#10;    // Enhanced function to send reply with status tracking&#10;    fun sendReply(conversationId: String, replyText: String) {&#10;        coroutineScope.launch {&#10;            try {&#10;                // Use RemoteReplyService to send the reply with retry mechanism&#10;                val result = RemoteReplyService.sendReply(&#10;                    context = context,&#10;                    conversationId = conversationId,&#10;                    replyText = replyText&#10;                )&#10;&#10;                if (result.success) {&#10;                    Toast.makeText(context, &quot;Reply sent successfully! &quot;, Toast.LENGTH_SHORT).show()&#10;                    // Clear any error messages&#10;                    sendingMessages = sendingMessages.toMutableMap().apply {&#10;                        remove(conversationId)&#10;                    }&#10;                } else {&#10;                    val errorMessage = when {&#10;                        result.error?.contains(&quot;No notification with reply action&quot;) == true -&gt;&#10;                            &quot;Cannot send reply: This notification doesn't support direct replies.&quot;&#10;                        result.canRetry -&gt;&#10;                            &quot;Failed to send reply after ${RemoteReplyService.MAX_RETRY_ATTEMPTS} attempts: ${result.error}&quot;&#10;                        else -&gt;&#10;                            &quot;Failed to send reply: ${result.error}&quot;&#10;                    }&#10;                    Toast.makeText(context, errorMessage, Toast.LENGTH_LONG).show()&#10;                }&#10;            } catch (e: Exception) {&#10;                Toast.makeText(context, &quot;Error sending reply: ${e.message}&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Manual retry function&#10;    fun retryReply(conversationId: String, replyText: String) {&#10;        // Clear previous status&#10;        RemoteReplyService.clearSendingStatus(conversationId)&#10;        sendingStatus = sendingStatus.toMutableMap().apply {&#10;            remove(conversationId)&#10;        }&#10;        sendingMessages = sendingMessages.toMutableMap().apply {&#10;            remove(conversationId)&#10;        }&#10;&#10;        // Retry sending&#10;        sendReply(conversationId, replyText)&#10;    }&#10;&#10;    // Pull to refresh simulation&#10;    LaunchedEffect(isRefreshing) {&#10;        if (isRefreshing) {&#10;            delay(1000) // Simulate refresh&#10;            isRefreshing = false&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(Color.White),&#10;        containerColor = Color.White,&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    Text(&#10;                        text = &quot;Smart Notifications&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 24.sp,&#10;                            color = Color(0xFF395B64)&#10;                        )&#10;                    )&#10;                },&#10;                actions = {&#10;                    IconButton(&#10;                        onClick = {&#10;                            // Clear notification memory store&#10;                            NotificationMemoryStore.clear()&#10;                            Toast.makeText(context, &quot;Notifications cleared&quot;, Toast.LENGTH_SHORT).show()&#10;                            isRefreshing = true&#10;                        }&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.Refresh,&#10;                            contentDescription = &quot;Clear notifications&quot;,&#10;                            tint = Color(0xFF395B64)&#10;                        )&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = Color.White&#10;                )&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .background(Color.White)&#10;                .padding(horizontal = 16.dp)&#10;        ) {&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Tab Row for Smart vs Raw&#10;            TabRow(&#10;                selectedTabIndex = selectedTab,&#10;                containerColor = Color.White,&#10;                contentColor = Color(0xFF395B64),&#10;                indicator = { tabPositions -&gt;&#10;                    TabRowDefaults.Indicator(&#10;                        Modifier.tabIndicatorOffset(tabPositions[selectedTab]),&#10;                        color = Color(0xFF395B64)&#10;                    )&#10;                }&#10;            ) {&#10;                Tab(&#10;                    selected = selectedTab == 0,&#10;                    onClick = { selectedTab = 0 },&#10;                    text = {&#10;                        Text(&#10;                            text = &quot;Smart&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontWeight = if (selectedTab == 0) FontWeight.Bold else FontWeight.Normal&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;                Tab(&#10;                    selected = selectedTab == 1,&#10;                    onClick = { selectedTab = 1 },&#10;                    text = {&#10;                        Text(&#10;                            text = &quot;Raw&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontWeight = if (selectedTab == 1) FontWeight.Bold else FontWeight.Normal&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Conditional rendering based on selected tab&#10;            when (selectedTab) {&#10;                0 -&gt; {&#10;                    // Smart Tab (existing functionality)&#10;                    SmartNotificationsContent(&#10;                        selectedFilter = selectedFilter,&#10;                        onFilterChange = { selectedFilter = it },&#10;                        isRefreshing = isRefreshing,&#10;                        filteredNotifications = filteredNotifications,&#10;                        generatingReplyFor = generatingReplyFor,&#10;                        sendingStatus = sendingStatus,&#10;                        sendingMessages = sendingMessages,&#10;                        onGenerateReply = { notificationHash -&gt; generateAIReply(notificationHash) },&#10;                        onSendReply = { conversationId, replyText -&gt; sendReply(conversationId, replyText) }&#10;                    )&#10;                }&#10;                1 -&gt; {&#10;                    // Raw Tab (new functionality)&#10;                    RawNotificationsContent(&#10;                        notifications = externalNotifications&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SmartNotificationsContent(&#10;    selectedFilter: ChatPlatform?,&#10;    onFilterChange: (ChatPlatform?) -&gt; Unit,&#10;    isRefreshing: Boolean,&#10;    filteredNotifications: List&lt;ChatNotification&gt;,&#10;    generatingReplyFor: String?,&#10;    sendingStatus: Map&lt;String, RemoteReplyService.ReplyStatus&gt;,&#10;    sendingMessages: Map&lt;String, String&gt;,&#10;    onGenerateReply: (String) -&gt; Unit,&#10;    onSendReply: (String, String) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;&#10;            // Platform Filter Chips&#10;            LazyRow(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                contentPadding = PaddingValues(vertical = 8.dp)&#10;            ) {&#10;                item {&#10;                    FilterChip(&#10;                        onClick = { onFilterChange(null) },&#10;                        label = { Text(&quot;All&quot;) },&#10;                        selected = selectedFilter == null,&#10;                        colors = FilterChipDefaults.filterChipColors(&#10;                            selectedContainerColor = Color(0xFF395B64),&#10;                            selectedLabelColor = Color.White&#10;                        )&#10;                    )&#10;                }&#10;&#10;                items(ChatPlatform.values().toList()) { platform -&gt;&#10;                    FilterChip(&#10;                        onClick = {&#10;                            onFilterChange(if (selectedFilter == platform) null else platform)&#10;                        },&#10;                        label = { Text(platform.displayName) },&#10;                        selected = selectedFilter == platform,&#10;                        colors = FilterChipDefaults.filterChipColors(&#10;                            selectedContainerColor = platform.color,&#10;                            selectedLabelColor = Color.White&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Loading indicator&#10;            AnimatedVisibility(visible = isRefreshing) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 16.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(&#10;                        color = Color(0xFF395B64),&#10;                        modifier = Modifier.size(32.dp),&#10;                        strokeWidth = 3.dp&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Notifications List&#10;            if (filteredNotifications.isEmpty()) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Notifications,&#10;                            contentDescription = &quot;No notifications&quot;,&#10;                            modifier = Modifier.size(48.dp),&#10;                            tint = Color(0xFF666666).copy(alpha = 0.5f)&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        Text(&#10;                            text = &quot;No notifications yet&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF666666)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            } else {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    items(filteredNotifications) { notification -&gt;&#10;                        EnhancedNotificationCard(&#10;                            notification = notification,&#10;                            onGenerateReply = { onGenerateReply(notification.notificationHash) },&#10;                            onSendReply = { onSendReply(notification.conversationId, notification.generatedReply) },&#10;                            onMarkAsRead = { /* Handle mark as read */ },&#10;                            isGeneratingReply = generatingReplyFor == notification.notificationHash,&#10;                            sendingStatus = sendingStatus[notification.conversationId],&#10;                            sentMessage = sendingMessages[notification.conversationId]&#10;                        )&#10;                    }&#10;&#10;                    item {&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                    }&#10;                }&#10;            }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun EnhancedNotificationCard(&#10;    notification: ChatNotification,&#10;    onGenerateReply: () -&gt; Unit,&#10;    onSendReply: () -&gt; Unit,&#10;    onMarkAsRead: (String) -&gt; Unit,&#10;    isGeneratingReply: Boolean,&#10;    sendingStatus: RemoteReplyService.ReplyStatus?,&#10;    sentMessage: String?&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    Card(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = if (notification.isRead) Color.White else Color(0xFFF0F8FF)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header with platform and timestamp&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(notification.platform.color)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = notification.platform.displayName,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontSize = 12.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = notification.platform.color&#10;                        )&#10;                    )&#10;&#10;                    // Reply action indicator&#10;                    if (notification.hasReplyAction) {&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Icon(&#10;                            imageVector = Icons.Default.Reply,&#10;                            contentDescription = &quot;Reply Available&quot;,&#10;                            modifier = Modifier.size(12.dp),&#10;                            tint = Color(0xFF4CAF50)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Text(&#10;                    text = formatTimestamp(notification.timestamp),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF666666)&#10;                    )&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Sender and message&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalAlignment = Alignment.Top&#10;            ) {&#10;                // Avatar&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(48.dp)&#10;                        .clip(CircleShape)&#10;                        .background(Color(0xFFA5C9CA))&#10;                ) {&#10;                    if (notification.senderAvatar != null) {&#10;                        AsyncImage(&#10;                            model = notification.senderAvatar,&#10;                            contentDescription = &quot;Sender Avatar&quot;,&#10;                            modifier = Modifier.fillMaxSize(),&#10;                            contentScale = ContentScale.Crop&#10;                        )&#10;                    } else {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Person,&#10;                            contentDescription = &quot;Default Avatar&quot;,&#10;                            modifier = Modifier.align(Alignment.Center),&#10;                            tint = Color.White&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                // Message content&#10;                Column(&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&#10;                        text = notification.senderName,&#10;                        style = MaterialTheme.typography.bodyLarge.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF395B64)&#10;                        )&#10;                    )&#10;&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;&#10;                    Text(&#10;                        text = notification.message,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF666666)&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;&#10;                // Unread indicator&#10;                if (!notification.isRead) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .size(8.dp)&#10;                            .clip(CircleShape)&#10;                            .background(Color(0xFF395B64))&#10;                    )&#10;                }&#10;            }&#10;&#10;            // AI Generated Reply Section&#10;            if (notification.hasGeneratedReply &amp;&amp; notification.generatedReply.isNotBlank()) {&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    shape = RoundedCornerShape(12.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFFF0F8FF).copy(alpha = 0.7f)&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(12.dp)&#10;                    ) {&#10;                        Row(&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.AutoAwesome,&#10;                                contentDescription = &quot;AI Generated&quot;,&#10;                                modifier = Modifier.size(16.dp),&#10;                                tint = Color(0xFF395B64)&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                text = &quot;AI Generated Reply&quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = AppFonts.KarlaFontFamily,&#10;                                    fontSize = 12.sp,&#10;                                    fontWeight = FontWeight.Bold,&#10;                                    color = Color(0xFF395B64)&#10;                                )&#10;                            )&#10;&#10;                            // Status indicators&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;&#10;                            when (sendingStatus) {&#10;                                RemoteReplyService.ReplyStatus.SENDING -&gt; {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        strokeWidth = 2.dp,&#10;                                        color = Color(0xFF2196F3)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Sending...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF2196F3)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.RETRYING -&gt; {&#10;                                    CircularProgressIndicator(&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        strokeWidth = 2.dp,&#10;                                        color = Color(0xFFFF9800)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Retrying...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFFFF9800)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.SENT -&gt; {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.CheckCircle,&#10;                                        contentDescription = &quot;Sent&quot;,&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        tint = Color(0xFF4CAF50)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Sent&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF4CAF50)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                RemoteReplyService.ReplyStatus.FAILED -&gt; {&#10;                                    Icon(&#10;                                        imageVector = Icons.Default.Error,&#10;                                        contentDescription = &quot;Failed&quot;,&#10;                                        modifier = Modifier.size(16.dp),&#10;                                        tint = Color(0xFFE53E3E)&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(4.dp))&#10;                                    Text(&#10;                                        text = &quot;Failed&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFFE53E3E)&#10;                                        )&#10;                                    )&#10;                                }&#10;                                else -&gt; {&#10;                                    if (notification.isSent) {&#10;                                        Icon(&#10;                                            imageVector = Icons.Default.CheckCircle,&#10;                                            contentDescription = &quot;Sent&quot;,&#10;                                            modifier = Modifier.size(16.dp),&#10;                                            tint = Color(0xFF4CAF50)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = notification.generatedReply,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFF333333)&#10;                            )&#10;                        )&#10;&#10;                        // Show status message if available&#10;                        if (sentMessage != null) {&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                            Text(&#10;                                text = sentMessage,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontSize = 11.sp,&#10;                                    color = when (sendingStatus) {&#10;                                        RemoteReplyService.ReplyStatus.FAILED -&gt; Color(0xFFE53E3E)&#10;                                        RemoteReplyService.ReplyStatus.RETRYING -&gt; Color(0xFFFF9800)&#10;                                        else -&gt; Color(0xFF666666)&#10;                                    }&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Action buttons&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                // Generate Reply Button&#10;                if (!notification.hasGeneratedReply &amp;&amp; !isGeneratingReply) {&#10;                    Button(&#10;                        onClick = onGenerateReply,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.AutoAwesome,&#10;                            contentDescription = &quot;Generate Reply&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Generate Reply&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Loading state for reply generation&#10;                if (isGeneratingReply) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while generating */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF395B64).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Generating...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 12.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Regenerate Reply Button (if reply exists and not currently sending)&#10;                if (notification.hasGeneratedReply &amp;&amp;&#10;                    !isGeneratingReply &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.SENDING &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.RETRYING) {&#10;&#10;                    OutlinedButton(&#10;                        onClick = onGenerateReply,&#10;                        colors = ButtonDefaults.outlinedButtonColors(&#10;                            contentColor = Color(0xFF395B64)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        modifier = Modifier.widthIn(min = 120.dp),&#10;                        contentPadding = PaddingValues(horizontal = 12.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Regenerate&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Regenerate&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 11.sp,&#10;                                fontWeight = FontWeight.Medium&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Spacer to push send button to the right&#10;                Spacer(modifier = Modifier.weight(1f))&#10;&#10;                // Send Reply Button (moved to the right side)&#10;                if (notification.hasGeneratedReply &amp;&amp;&#10;                    notification.hasReplyAction &amp;&amp;&#10;                    !notification.isSent &amp;&amp;&#10;                    !isGeneratingReply &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.SENDING &amp;&amp;&#10;                    sendingStatus != RemoteReplyService.ReplyStatus.RETRYING) {&#10;&#10;                    Button(&#10;                        onClick = onSendReply,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF4CAF50)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Send,&#10;                            contentDescription = &quot;Send Reply&quot;,&#10;                            modifier = Modifier.size(18.dp),&#10;                            tint = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Send&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Sending state button&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.SENDING) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while sending */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFF2196F3).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Sending...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Retrying state button&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.RETRYING) {&#10;                    Button(&#10;                        onClick = { /* Do nothing while retrying */ },&#10;                        enabled = false,&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFFF9800).copy(alpha = 0.6f)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(16.dp),&#10;                            strokeWidth = 2.dp,&#10;                            color = Color.White&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Retrying...&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Retry button for failed sends&#10;                if (sendingStatus == RemoteReplyService.ReplyStatus.FAILED) {&#10;                    Button(&#10;                        onClick = {&#10;                            coroutineScope.launch {&#10;                                // Retry sending&#10;                                RemoteReplyService.sendReply(&#10;                                    context = context,&#10;                                    conversationId = notification.conversationId,&#10;                                    replyText = notification.generatedReply&#10;                                )&#10;                            }&#10;                        },&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = Color(0xFFE53E3E)&#10;                        ),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Refresh,&#10;                            contentDescription = &quot;Retry&quot;,&#10;                            modifier = Modifier.size(16.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(6.dp))&#10;                        Text(&#10;                            text = &quot;Retry&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = AppFonts.KarlaFontFamily,&#10;                                fontSize = 13.sp,&#10;                                fontWeight = FontWeight.Bold&#10;                            ),&#10;                            maxLines = 1&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// Helper function to format timestamps&#10;@Composable&#10;fun formatTimestamp(timestamp: Long): String {&#10;    val now = System.currentTimeMillis()&#10;    val diff = now - timestamp&#10;&#10;    return when {&#10;        diff &lt; 60 * 1000 -&gt; &quot;now&quot;&#10;        diff &lt; 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 1000)}m ago&quot;&#10;        diff &lt; 24 * 60 * 60 * 1000 -&gt; &quot;${diff / (60 * 60 * 1000)}h ago&quot;&#10;        diff &lt; 48 * 60 * 60 * 1000 -&gt; &quot;yesterday&quot;&#10;        else -&gt; {&#10;            SimpleDateFormat(&quot;MMM dd&quot;, Locale.getDefault()).format(Date(timestamp))&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RawNotificationsContent(&#10;    notifications: List&lt;NotificationMemoryStore.ExternalNotification&gt;&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        if (notifications.isEmpty()) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(32.dp),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Code,&#10;                        contentDescription = &quot;No raw data&quot;,&#10;                        modifier = Modifier.size(48.dp),&#10;                        tint = Color(0xFF666666).copy(alpha = 0.5f)&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot;No raw notification data&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF666666)&#10;                        )&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Text(&#10;                        text = &quot;Notifications will appear here in raw format&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = AppFonts.KaiseiDecolFontFamily,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF999999)&#10;                        ),&#10;                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;        } else {&#10;            LazyColumn(&#10;                modifier = Modifier.fillMaxSize(),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp),&#10;                contentPadding = PaddingValues(vertical = 8.dp)&#10;            ) {&#10;                items(notifications) { notification -&gt;&#10;                    RawNotificationCard(notification = notification)&#10;                }&#10;&#10;                item {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RawNotificationCard(&#10;    notification: NotificationMemoryStore.ExternalNotification&#10;) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable { isExpanded = !isExpanded },&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = Color(0xFFF5F5F5)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header with expand/collapse icon&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Code,&#10;                        contentDescription = &quot;Raw Data&quot;,&#10;                        modifier = Modifier.size(16.dp),&#10;                        tint = Color(0xFF1BC994)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&#10;                        text = notification.packageName.split(&quot;.&quot;).lastOrNull() ?: notification.packageName,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF1BC994)&#10;                        )&#10;                    )&#10;                }&#10;&#10;                Icon(&#10;                    imageVector = if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,&#10;                    contentDescription = if (isExpanded) &quot;Collapse&quot; else &quot;Expand&quot;,&#10;                    tint = Color(0xFF666666)&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // Always visible: Hash (for identification)&#10;            RawDataField(label = &quot;Hash&quot;, value = notification.hash.take(16) + &quot;...&quot;)&#10;&#10;            // Expandable content&#10;            if (isExpanded) {&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                // Show processed fields first&#10;                Text(&#10;                    text = &quot;Processed Fields:&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = AppFonts.KarlaFontFamily,&#10;                        fontWeight = FontWeight.Bold,&#10;                        fontSize = 13.sp,&#10;                        color = Color(0xFF1BC994)&#10;                    )&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                RawDataField(label = &quot;Title&quot;, value = notification.title)&#10;                RawDataField(label = &quot;Text&quot;, value = notification.text)&#10;                RawDataField(label = &quot;Package Name&quot;, value = notification.packageName)&#10;                RawDataField(label = &quot;Timestamp&quot;, value = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault()).format(Date(notification.time)))&#10;                RawDataField(label = &quot;Sender&quot;, value = notification.sender ?: &quot;(null)&quot;)&#10;                RawDataField(label = &quot;Conversation Title&quot;, value = notification.conversationTitle ?: &quot;(null)&quot;)&#10;                RawDataField(label = &quot;Conversation ID&quot;, value = notification.conversationId)&#10;                RawDataField(label = &quot;Has Reply Action&quot;, value = notification.hasReplyAction.toString())&#10;                RawDataField(label = &quot;AI Reply&quot;, value = notification.ai_reply.ifBlank { &quot;(empty)&quot; })&#10;                RawDataField(label = &quot;Is Sent&quot;, value = notification.is_sent.toString())&#10;                RawDataField(label = &quot;Full Hash&quot;, value = notification.hash)&#10;&#10;                // Show ALL raw extras&#10;                if (notification.rawExtras.isNotEmpty()) {&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                    Text(&#10;                        text = &quot;Raw Notification Extras (${notification.rawExtras.size} fields):&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 13.sp,&#10;                            color = Color(0xFFFF6B00)&#10;                        )&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    notification.rawExtras.forEach { (key, value) -&gt;&#10;                        RawDataField(label = key, value = value)&#10;                    }&#10;                }&#10;&#10;                // JSON-like representation&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                val context = LocalContext.current&#10;                val jsonString = remember(notification) {&#10;                    buildString {&#10;                        appendLine(&quot;{&quot;)&#10;                        appendLine(&quot;  \&quot;title\&quot;: \&quot;${notification.title}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;text\&quot;: \&quot;${notification.text}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;packageName\&quot;: \&quot;${notification.packageName}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;time\&quot;: ${notification.time},&quot;)&#10;                        appendLine(&quot;  \&quot;sender\&quot;: ${if (notification.sender != null) &quot;\&quot;${notification.sender}\&quot;&quot; else &quot;null&quot;},&quot;)&#10;                        appendLine(&quot;  \&quot;conversationTitle\&quot;: ${if (notification.conversationTitle != null) &quot;\&quot;${notification.conversationTitle}\&quot;&quot; else &quot;null&quot;},&quot;)&#10;                        appendLine(&quot;  \&quot;conversationId\&quot;: \&quot;${notification.conversationId}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;hasReplyAction\&quot;: ${notification.hasReplyAction},&quot;)&#10;                        appendLine(&quot;  \&quot;ai_reply\&quot;: \&quot;${notification.ai_reply}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;is_sent\&quot;: ${notification.is_sent},&quot;)&#10;                        appendLine(&quot;  \&quot;hash\&quot;: \&quot;${notification.hash}\&quot;,&quot;)&#10;                        appendLine(&quot;  \&quot;rawExtras\&quot;: {&quot;)&#10;                        notification.rawExtras.entries.forEachIndexed { index, (key, value) -&gt;&#10;                            val isLast = index == notification.rawExtras.size - 1&#10;                            val escapedValue = value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;).replace(&quot;\n&quot;, &quot;\\n&quot;)&#10;                            appendLine(&quot;    \&quot;$key\&quot;: \&quot;$escapedValue\&quot;${if (!isLast) &quot;,&quot; else &quot;&quot;}&quot;)&#10;                        }&#10;                        appendLine(&quot;  }&quot;)&#10;                        append(&quot;}&quot;)&#10;                    }&#10;                }&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Complete JSON Structure:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = AppFonts.KarlaFontFamily,&#10;                            fontWeight = FontWeight.Bold,&#10;                            fontSize = 13.sp,&#10;                            color = Color(0xFF00FF00)&#10;                        )&#10;                    )&#10;&#10;                    IconButton(&#10;                        onClick = {&#10;                            val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager&#10;                            val clip = ClipData.newPlainText(&quot;Notification JSON&quot;, jsonString)&#10;                            clipboard.setPrimaryClip(clip)&#10;                            Toast.makeText(context, &quot;JSON copied to clipboard!&quot;, Toast.LENGTH_SHORT).show()&#10;                        },&#10;                        modifier = Modifier.size(32.dp)&#10;                    ) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.ContentCopy,&#10;                            contentDescription = &quot;Copy JSON&quot;,&#10;                            tint = Color(0xFF00FF00),&#10;                            modifier = Modifier.size(18.dp)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                Surface(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    shape = RoundedCornerShape(8.dp),&#10;                    color = Color(0xFF2D2D2D)&#10;                ) {&#10;                    Text(&#10;                        text = jsonString,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = Color(0xFF00FF00),&#10;                            lineHeight = 16.sp&#10;                        ),&#10;                        modifier = Modifier.padding(12.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RawDataField(&#10;    label: String,&#10;    value: String&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp)&#10;    ) {&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = AppFonts.KarlaFontFamily,&#10;                fontWeight = FontWeight.Bold,&#10;                fontSize = 11.sp,&#10;                color = Color(0xFF666666)&#10;            )&#10;        )&#10;        Spacer(modifier = Modifier.height(2.dp))&#10;        Surface(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            shape = RoundedCornerShape(4.dp),&#10;            color = Color.White&#10;        ) {&#10;            Text(&#10;                text = value,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = androidx.compose.ui.text.font.FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF191919)&#10;                ),&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>